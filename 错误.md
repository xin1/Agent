```
from fastapi.responses import JSONResponse

@app.post("/process_batch")
async def process_batch(
    files: List[UploadFile] = File(...),
    top_cm: float = Form(0),
    bottom_cm: float = Form(0)
):
    output_dir = "processed"
    os.makedirs(output_dir, exist_ok=True)

    results = []
    errors = []

    for file in files:
        filename = unquote(file.filename)
        ext = filename.split(".")[-1].lower()
        try:
            if ext in ("doc", "docx"):
                pdf_path = convert_doc_to_pdf(file)
                with open(pdf_path, "rb") as f:
                    pdf_bytes = f.read()
                csv_path = process_pdf_and_extract(BytesIO(pdf_bytes), top_cm, bottom_cm, filename=filename)
            elif ext == "pdf":
                pdf_bytes = await file.read()
                csv_path = process_pdf_and_extract(BytesIO(pdf_bytes), top_cm, bottom_cm, filename=filename)
            else:
                raise ValueError("Unsupported file type")
            results.append(csv_path)
        except Exception as e:
            print(f"❌ Error processing {filename}: {e}")
            errors.append(filename)
            continue

    if not results:
        return JSONResponse(status_code=500, content={"message": "All files failed to process", "errors": errors})

    # 生成结果 ZIP
    if len(results) == 1:
        return FileResponse(results[0], filename=os.path.basename(results[0]))
    else:
        zip_path = create_zip(results, output_dir)
        return FileResponse(zip_path, filename=os.path.basename(zip_path))


```
这个错误信息清晰地指出了你的问题出在这里：

```
TypeError: bad stream: type(stream)=<class 'str'>
```

### 错误根因：

你调用了 `fitz.open(stream=..., filetype="pdf")`，但传入的 `stream` 实际是一个字符串（str 类型），而不是期望的 `bytes`、`BytesIO` 或可读取流（比如文件对象）。

---

### 问题出现在你调用 `process_pdf_and_extract()` 的方式：

在 `app.py` 中第 63 行：

```python
csv_path = process_pdf_and_extract(pdf_path, top_cm, bottom_cm)
```

这里 `pdf_path` 是字符串路径，而你在 `process_pdf_and_extract()` 中调用的是：

```python
pdf = fitz.open(stream=file.read() if hasattr(file, "read") else file, filetype="pdf")
```

当传入的是字符串 `pdf_path`，就走到了 `else file`，即 `fitz.open(stream=pdf_path, filetype="pdf")`，而 `fitz.open()` 不支持字符串作为 `stream` 参数。

---

### ✅ 正确做法：

你应该改为：

```python
pdf = fitz.open(file)  # 如果是文件路径，直接传路径，fitz 会自动识别
```

或者更健壮：

```python
if hasattr(file, "read"):  # 是 BytesIO 或 UploadFile
    pdf = fitz.open(stream=file.read(), filetype="pdf")
else:  # 是路径字符串
    pdf = fitz.open(file)
```

---

### ✅ 推荐修复方案：

在 `process.py` 中 `process_pdf_and_extract()` 函数里，修改如下：

```python
import fitz  # PyMuPDF

def process_pdf_and_extract(file, top_cm, bottom_cm, filename=None):
    # 处理传入的 file 参数：可能是 BytesIO、UploadFile 或 str 路径
    if hasattr(file, "read"):
        pdf = fitz.open(stream=file.read(), filetype="pdf")
    elif isinstance(file, (bytes, bytearray)):
        pdf = fitz.open(stream=file, filetype="pdf")
    elif isinstance(file, str):
        pdf = fitz.open(file)  # 是一个 PDF 文件路径
    else:
        raise TypeError(f"Unsupported file input type: {type(file)}")

    # 后续你的逻辑保持不变...
```

---

### ✅ 补充建议：

你在上传 Word 文件时，用 `convert_doc_to_pdf(file)` 只返回了 PDF 路径（str），但 `process_pdf_and_extract()` 期望的是 BytesIO 或可读取对象。这两处的处理方式应该统一，比如将 Word 转 PDF 后读取内容为 BytesIO 传入，或者统一都让 `process_pdf_and_extract()` 支持文件路径。

---

### ✅ 统一处理建议（推荐）：

在 `app.py` 中修改：

```python
if ext in ("doc", "docx"):
    # Word 转 PDF 后读取 PDF 内容
    pdf_path = convert_doc_to_pdf(file)
    with open(pdf_path, "rb") as f:
        pdf_bytes = f.read()
    csv_path = process_pdf_and_extract(BytesIO(pdf_bytes), top_cm, bottom_cm, filename=file.filename)
```

这样你就不用修改 `process_pdf_and_extract()` 的实现方式了，保持所有传入都是 BytesIO，一致性更好。

---

如需我帮你重构完整代码或模块结构，也可以继续发我。

```
ERROR:    Exception in ASGI application
Traceback (most recent call last):
  File "/usr/local/lib/python3.9/site-packages/uvicorn/protocols/http/h11_impl.py", line 403, in run_asgi
    result = await app(  # type: ignore[func-returns-value]
  File "/usr/local/lib/python3.9/site-packages/uvicorn/middleware/proxy_headers.py", line 60, in __call__
    return await self.app(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/fastapi/applications.py", line 1054, in __call__
    await super().__call__(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/applications.py", line 112, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/middleware/errors.py", line 187, in __call__
    raise exc
  File "/usr/local/lib/python3.9/site-packages/starlette/middleware/errors.py", line 165, in __call__
    await self.app(scope, receive, _send)
  File "/usr/local/lib/python3.9/site-packages/starlette/middleware/cors.py", line 93, in __call__
    await self.simple_response(scope, receive, send, request_headers=headers)
  File "/usr/local/lib/python3.9/site-packages/starlette/middleware/cors.py", line 144, in simple_response
    await self.app(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/middleware/exceptions.py", line 62, in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/usr/local/lib/python3.9/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/usr/local/lib/python3.9/site-packages/starlette/routing.py", line 714, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/routing.py", line 734, in app
    await route.handle(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/routing.py", line 288, in handle
    await self.app(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/routing.py", line 76, in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/usr/local/lib/python3.9/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/usr/local/lib/python3.9/site-packages/starlette/routing.py", line 73, in app
    response = await f(request)
  File "/usr/local/lib/python3.9/site-packages/fastapi/routing.py", line 301, in app
    raw_response = await run_endpoint_function(
  File "/usr/local/lib/python3.9/site-packages/fastapi/routing.py", line 212, in run_endpoint_function
    return await dependant.call(**values)
  File "/app/app.py", line 63, in process_batch
    csv_path = process_pdf_and_extract(pdf_path, top_cm, bottom_cm)
  File "/app/process.py", line 11, in process_pdf_and_extract
    pdf = fitz.open(stream=file.read() if hasattr(file, "read") else file, filetype="pdf")
  File "/usr/local/lib/python3.9/site-packages/pymupdf/__init__.py", line 2926, in __init__
    raise TypeError(f"bad stream: {type(stream)=}.")
TypeError: bad stream: type(stream)=<class 'str'>.
```
```
# process.py
import os
import fitz  # PyMuPDF
import csv
import re
from uuid import uuid4
from convert_doc import convert_doc_to_pdf
from io import BytesIO

os.makedirs("outputs", exist_ok=True)

def process_pdf_and_extract(file, top_cm, bottom_cm):
    filename = file.filename.rsplit(".", 1)[0]

    # 判断是否是 Word 文件
    ext = file.filename.rsplit(".", 1)[-1].lower()
    if ext in ("doc", "docx"):
        pdf_path = convert_doc_to_pdf(file)
        doc = fitz.open(pdf_path)
    else:
        # PDF 文件：使用 file.file.read()
        pdf_bytes = file.file.read()
        doc = fitz.open(stream=pdf_bytes, filetype="pdf")

    csv_path = f"outputs/{filename}.csv"
    heading_pattern = re.compile(r'^(\d+(\.\d+)*)(\s+)(.+)')  # 1、1.1、1.1.1 标题
    current_heading = None
    content_dict = {}

    for page in doc:
        rect = page.rect
        top = top_cm * 28.35
        bottom = bottom_cm * 28.35
        clip = fitz.Rect(rect.x0, rect.y0 + top, rect.x1, rect.y1 - bottom)
        blocks = page.get_text("blocks", clip=clip)
        sorted_blocks = sorted(blocks, key=lambda b: (b[1], b[0]))  # 从上到下排序

        for block in sorted_blocks:
            text = block[4].strip()
            if not text:
                continue
            match = heading_pattern.match(text)
            if match:
                current_heading = f"{match.group(1)} {match.group(4).strip()}"
                content_dict[current_heading] = ""
            elif current_heading:
                content_dict[current_heading] += text + " "

    with open(csv_path, "w", newline="", encoding="utf-8-sig") as f:
        writer = csv.writer(f)
        for heading, content in content_dict.items():
            writer.writerow([heading, content.strip()])

    return csv_path
```
