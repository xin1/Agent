ä½ æè¿°çš„ç°è±¡æ˜¯ï¼š
**ä¸Šä¼  PDF å’Œ Word æ–‡ä»¶æ··åˆåï¼Œåç«¯å¤„ç†æˆåŠŸï¼ˆCSV å·²ç”Ÿæˆï¼‰ï¼Œä½†å‰ç«¯ `xhr.onload` ä¸­ JSON è§£æå¤±è´¥ï¼Œæ˜¾ç¤ºâ€œå¤„ç†å‡ºé”™ï¼â€**

è¿™è¯´æ˜ï¼š
âœ… åç«¯æ²¡æœ‰çœŸæ­£å´©æºƒï¼Œ
âŒ ä½†è¿”å›çš„ `xhr.responseText` **ä¸æ˜¯æ ‡å‡† JSON**ï¼Œå¯¼è‡´è¿™å¥æŠ¥é”™ï¼š

```js
const res = JSON.parse(xhr.responseText); // âŒ å¤±è´¥
```

---

## âœ… é—®é¢˜æœ¬è´¨

FastAPI é»˜è®¤åœ¨å¼‚å¸¸æ—¶è¿”å› **HTML é”™è¯¯é¡µ**ï¼Œ**è€Œä½ ä¸Šä¼  Word + PDF çš„ç»„åˆæ—¶å¯èƒ½è§¦å‘äº†æŸç§å¼‚å¸¸æˆ–æ—¥å¿—è¾“å‡º**ï¼Œä½†å¤„ç†æµç¨‹æœ¬èº«æ²¡ç‚¸ï¼Œåªæ˜¯è¿”å›å†…å®¹ä¸æ˜¯ JSONã€‚

---

## âœ… è§£å†³æ–¹æ³•ï¼šä¿®æ”¹ FastAPIï¼Œç¡®ä¿å§‹ç»ˆè¿”å›æ ‡å‡† JSONï¼ˆå…³é”®ï¼‰

è¯·å¯¹ `/process_batch/` æ·»åŠ å®Œæ•´çš„å¼‚å¸¸å¤„ç†é€»è¾‘ï¼Œç¡®ä¿**æ— è®ºæˆåŠŸè¿˜æ˜¯å¤±è´¥ï¼Œè¿”å›éƒ½æ˜¯ JSONResponse**ï¼š

### ğŸ”§ å®Œæ•´ä¿®å¤ç‰ˆ `/process_batch/`

```python
from fastapi.responses import JSONResponse
from fastapi import Request
import traceback

@app.post("/process_batch/")
async def process_batch(
    files: List[UploadFile] = File(...),
    top_cm: float = Form(...),
    bottom_cm: float = Form(...)
):
    try:
        csv_paths = []

        for file in files:
            ext = file.filename.rsplit(".", 1)[-1].lower()

            if ext in ("doc", "docx"):
                pdf_path = convert_doc_to_pdf(file)
                with open(pdf_path, "rb") as f:
                    pdf_bytes = f.read()
                csv_path = process_pdf_and_extract(BytesIO(pdf_bytes), top_cm, bottom_cm, filename=file.filename)
            else:
                file_bytes = await file.read()
                csv_path = process_pdf_and_extract(BytesIO(file_bytes), top_cm, bottom_cm, filename=file.filename)

            csv_paths.append(csv_path)

        if len(csv_paths) == 1:
            return JSONResponse(content={"path": csv_paths[0], "is_zip": False})
        else:
            zip_path = zip_csvs(csv_paths)
            return JSONResponse(content={"path": zip_path, "is_zip": True})

    except Exception as e:
        # æ‰“å°é”™è¯¯æ—¥å¿—æ–¹ä¾¿è°ƒè¯•
        traceback.print_exc()
        return JSONResponse(
            status_code=500,
            content={"error": "æ–‡æ¡£å¤„ç†å¤±è´¥", "detail": str(e)}
        )
```

---

## âœ… å»ºè®®å‰ç«¯åŠ ä¸Šè°ƒè¯•æ‰“å°

ä¿®æ”¹å‰ç«¯ `xhr.onload` çš„ `catch` å—ï¼Œå¢åŠ è°ƒè¯•è¾“å‡ºï¼š

```js
xhr.onload = () => {
  try {
    const res = JSON.parse(xhr.responseText);  // âŒ å¤±è´¥ç‚¹
    document.getElementById("download-links").classList.remove("hidden");
    const csvLink = document.getElementById("csv-link");
    csvLink.href = `/download/?path=${encodeURIComponent(res.path)}`;
    
    if (res.is_zip) {
      document.getElementById("download-text").textContent = "ä¸‹è½½CSVå‹ç¼©åŒ…";
      csvLink.innerHTML = '<i class="fas fa-file-archive"></i> ä¸‹è½½CSVå‹ç¼©åŒ…';
    } else {
      document.getElementById("download-text").textContent = "ä¸‹è½½CSVæ–‡ä»¶";
      csvLink.innerHTML = '<i class="fas fa-file-csv"></i> ä¸‹è½½CSVæ–‡ä»¶';
    }

    progressText.textContent = "å¤„ç†å®Œæˆï¼";
    bar.value = 100;

  } catch (e) {
    console.warn("è¿”å›å†…å®¹æ— æ³•è§£æä¸º JSONï¼š", xhr.responseText);
    progressText.textContent = "å¤„ç†å‡ºé”™ï¼";
    alert("å¤„ç†è¿‡ç¨‹ä¸­å‡ºé”™ï¼Œè¯·é‡è¯•");
  }

  processBtn.disabled = false;
  processBtn.innerHTML = '<i class="fas fa-play"></i> å¼€å§‹å¤„ç†PDFæ–‡ä»¶';
};
```

---

## âœ… æ¨èè°ƒè¯•æ­¥éª¤

1. **åœ¨å‰ç«¯æ‰“å° `xhr.responseText`**ï¼ŒæŸ¥çœ‹æ˜¯å¦æ˜¯ HTML é”™è¯¯é¡µã€‚
2. **ç¡®ä¿åç«¯ `.read()` å’Œ `BytesIO()` éƒ½å†™å¯¹äº†ï¼ŒWord å’Œ PDF çš„æµç¨‹ä¸€è‡´ã€‚**
3. **çœ‹ä¸€ä¸‹ convert\_doc\_to\_pdf æ˜¯å¦æŠ›é”™å´æ²¡ä¸­æ–­æµç¨‹ã€‚**

---

å¦‚æœä½ æ„¿æ„ï¼Œæˆ‘ä¹Ÿå¯ä»¥å¸®ä½ æ£€æŸ¥ `convert_doc_to_pdf()` æ˜¯å¦æœ‰è¾¹ç•Œå¼‚å¸¸æœªå¤„ç†ï¼Œæˆ–è€…ä¸€æ¬¡æ€§æ‰“åŒ…å‰åç«¯ä¿®å¤ç‰ˆã€‚è¦ä¸è¦æˆ‘ä¸€èµ·ç»™ï¼Ÿ

æ„Ÿè°¢ä½ è¡¥å……äº†å®Œæ•´çš„å‰ç«¯ `processPDFs()` ä»£ç ã€‚

ä½ ä¹‹å‰æåˆ°çš„é—®é¢˜æ˜¯ï¼š

> å®é™…åç«¯å¤„ç†æˆåŠŸã€æ–‡ä»¶å·²ç”Ÿæˆï¼Œä½†å‰ç«¯å¼¹å‡ºâ€œå¤„ç†è¿‡ç¨‹ä¸­å‡ºé”™â€ï¼Œè¯´æ˜ **å‰ç«¯ `xhr.onload` çš„ JSON è§£æå¤±è´¥äº†**ã€‚

---

## âœ… é—®é¢˜åˆ†æ

åœ¨ä½ è¿™æ®µä»£ç é‡Œï¼Œæ ¸å¿ƒé€»è¾‘æ˜¯ï¼š

```javascript
xhr.onload = () => {
  try {
    const res = JSON.parse(xhr.responseText); // å¦‚æœä¸æ˜¯ JSONï¼Œä¼šè¿›å…¥ catch
    ...
  } catch (e) {
    progressText.textContent = "å¤„ç†å‡ºé”™ï¼";
    alert("å¤„ç†è¿‡ç¨‹ä¸­å‡ºé”™ï¼Œè¯·é‡è¯•");
  }
};
```

âš ï¸ **ä¸€æ—¦åç«¯è¿”å›çš„ä¸æ˜¯çº¯ JSONï¼ˆæ¯”å¦‚ HTML æŠ¥é”™é¡µé¢æˆ–æ—¥å¿—ï¼‰ï¼Œå°±ä¼šè§¦å‘ catchï¼Œå‰ç«¯ä»¥ä¸ºâ€œå‡ºé”™â€**ï¼Œå“ªæ€•å®é™…æ–‡ä»¶å·²ç”Ÿæˆã€‚

---

## âœ… æ­£ç¡®åšæ³•ï¼šå…ˆåˆ¤æ–­ `xhr.status` å’Œ `Content-Type` ç±»å‹

ä½ å¯ä»¥è¿™æ ·ä¿®æ”¹ `xhr.onload`ï¼Œç¡®ä¿åªæœ‰çœŸå‡ºé”™æ‰å¼¹çª—ï¼š

### âœ… **æ”¹è¿›ç‰ˆ `xhr.onload`ï¼š**

```javascript
xhr.onload = () => {
  const contentType = xhr.getResponseHeader("Content-Type") || "";
  
  if (xhr.status === 200 && contentType.includes("application/json")) {
    try {
      const res = JSON.parse(xhr.responseText);

      document.getElementById("download-links").classList.remove("hidden");
      const csvLink = document.getElementById("csv-link");
      csvLink.href = `/download/?path=${encodeURIComponent(res.path)}`;
      
      if (res.is_zip) {
        document.getElementById("download-text").textContent = "ä¸‹è½½CSVå‹ç¼©åŒ…";
        csvLink.innerHTML = '<i class="fas fa-file-archive"></i> ä¸‹è½½CSVå‹ç¼©åŒ…';
      } else {
        document.getElementById("download-text").textContent = "ä¸‹è½½CSVæ–‡ä»¶";
        csvLink.innerHTML = '<i class="fas fa-file-csv"></i> ä¸‹è½½CSVæ–‡ä»¶';
      }
      
      progressText.textContent = "å¤„ç†å®Œæˆï¼";
      bar.value = 100;
    } catch (e) {
      progressText.textContent = "ç»“æœè§£æå¤±è´¥ï¼";
      alert("å¤„ç†å®Œæˆï¼Œä½†è¿”å›ç»“æœæ— æ³•è§£æï¼Œè¯·æ£€æŸ¥åç«¯æ˜¯å¦è¿”å›äº†JSON");
    }
  } else {
    progressText.textContent = "å¤„ç†å‡ºé”™ï¼";
    alert("å¤„ç†è¿‡ç¨‹ä¸­å‡ºé”™ï¼Œè¿”å›çŠ¶æ€ç ï¼š" + xhr.status);
    console.warn("å“åº”å†…å®¹:", xhr.responseText);
  }

  processBtn.disabled = false;
  processBtn.innerHTML = '<i class="fas fa-play"></i> å¼€å§‹å¤„ç†PDFæ–‡ä»¶';
};
```

---

## âœ… åç«¯å»ºè®®ï¼šç¡®ä¿è¿”å›æ˜¯ JSON æ ¼å¼

```python
from fastapi.responses import JSONResponse

return JSONResponse(content={"path": zip_path, "is_zip": True})
```

æˆ–è€…ç¡®ä¿å¼‚å¸¸æ—¶è¿”å›æ˜ç¡®çš„ JSONï¼Œè€Œä¸æ˜¯ HTMLï¼š

```python
return JSONResponse(status_code=500, content={"error": "Something went wrong"})
```

---

## âœ… æ€»ç»“

| é—®é¢˜                      | è§£å†³æ–¹æ¡ˆ                                |
| ----------------------- | ----------------------------------- |
| response ä¸æ˜¯ JSON å¯¼è‡´å‰ç«¯æŠ¥é”™ | åˆ¤æ–­ `Content-Type` åå† `JSON.parse()` |
| åç«¯é”™è¯¯è¿”å›äº† HTML            | åç«¯ç»Ÿä¸€ç”¨ JSON è¿”å›é”™è¯¯                     |
| æ–‡ä»¶å…¶å®å·²ç”Ÿæˆï¼Œä½†å‰ç«¯è¯¯åˆ¤å¤±è´¥         | å‰ç«¯ä¸è¦ç›²ç›® `try JSON.parse()`ï¼Œåº”æ£€æŸ¥ç±»å‹     |

å¦‚ä½ éœ€è¦æˆ‘å¸®ä½ æ”¹åç«¯è¿”å›é€»è¾‘ï¼Œä¹Ÿå¯ä»¥è´´ä¸Š `/process_batch/` çš„ FastAPI è·¯ç”±é€»è¾‘ã€‚

éå¸¸å¥½ï¼Œä½ çš„ `/process_batch/` è·¯ç”±é€»è¾‘å·²ç»æ˜¯æˆåŠŸè¿”å› JSON æ ¼å¼æ•°æ®çš„ï¼š

```python
return {"path": csv_paths[0], "is_zip": False}
```

ä½†ä½ åœ¨ **æ²¡æœ‰æŒ‡å®šå“åº”ç±»å‹**ï¼ŒFastAPI é»˜è®¤æ˜¯ `application/json`ï¼Œç†è®ºä¸Šå‰ç«¯èƒ½æ­£å¸¸è§£æï¼Œä½†**åœ¨æŸäº›å¼‚å¸¸æˆ–é”™è¯¯æ—¶ï¼Œè¿”å›çš„å¯èƒ½æ˜¯ HTML æŠ¥é”™é¡µé¢**ï¼Œå‰ç«¯ `JSON.parse()` å°±ç‚¸äº†ã€‚

---

## âœ… å»ºè®®ä¸€ï¼šæ˜ç¡®æŒ‡å®šè¿”å›ç±»å‹ä¸º JSON

ä½ å¯ä»¥æ˜ç¡®è®¾ç½®å“åº”ç±»å‹ï¼Œç¡®ä¿æµè§ˆå™¨ä¸è¯¯åˆ¤ï¼š

```python
from fastapi.responses import JSONResponse

# åœ¨å•æ–‡ä»¶è¿”å›æ—¶ï¼š
return JSONResponse(content={"path": csv_paths[0], "is_zip": False})

# å¤šæ–‡ä»¶å‹ç¼©æ—¶ï¼š
return JSONResponse(content={"path": zip_path, "is_zip": True})
```

---

## âœ… å»ºè®®äºŒï¼šå¼‚å¸¸ç»Ÿä¸€è¿”å› JSONï¼ˆé¿å… HTML æŠ¥é”™ï¼‰

ç»™ `process_batch()` åŠ ä¸€ä¸ªç»Ÿä¸€å¼‚å¸¸æ•è·ï¼ˆå¯é€‰å¢å¼ºï¼‰ï¼š

```python
from fastapi.responses import JSONResponse
from fastapi import Request
import traceback

@app.post("/process_batch/")
async def process_batch(
    files: List[UploadFile] = File(...),
    top_cm: float = Form(...),
    bottom_cm: float = Form(...)
):
    try:
        csv_paths = []

        for file in files:
            ext = file.filename.rsplit(".", 1)[-1].lower()

            if ext in ("doc", "docx"):
                pdf_path = convert_doc_to_pdf(file)
                with open(pdf_path, "rb") as f:
                    pdf_bytes = f.read()
                csv_path = process_pdf_and_extract(BytesIO(pdf_bytes), top_cm, bottom_cm, filename=file.filename)
            else:
                file_bytes = await file.read()
                csv_path = process_pdf_and_extract(BytesIO(file_bytes), top_cm, bottom_cm, filename=file.filename)

            csv_paths.append(csv_path)

        if len(csv_paths) == 1:
            return JSONResponse(content={"path": csv_paths[0], "is_zip": False})
        else:
            zip_path = zip_csvs(csv_paths)
            return JSONResponse(content={"path": zip_path, "is_zip": True})

    except Exception as e:
        traceback.print_exc()
        return JSONResponse(status_code=500, content={"error": "å¤„ç†å¤±è´¥", "detail": str(e)})
```

è¿™æ ·å³ä½¿å¤„ç†å¤±è´¥ï¼Œå‰ç«¯ä¹Ÿèƒ½æ”¶åˆ°æ ‡å‡† JSONï¼Œ`xhr.onload` çš„ JSON.parse å°±ä¸ä¼šç‚¸ã€‚

---

## âœ… å‰ç«¯ + åç«¯è”åˆä¿®å¤æ€»ç»“

| æ–¹é¢       | å»ºè®®                                                |
| -------- | ------------------------------------------------- |
| åç«¯æ­£å¸¸è¿”å›   | ä½¿ç”¨ `JSONResponse(content={...})` æ˜ç¡®å“åº”ç±»å‹           |
| åç«¯å¼‚å¸¸å¤„ç†   | æ•è·å¼‚å¸¸å¹¶è¿”å›æ ‡å‡† JSONï¼ˆé HTML æŠ¥é”™é¡µï¼‰                        |
| å‰ç«¯ JS è§£æ | æ£€æŸ¥ `xhr.status` å’Œ `Content-Type`ï¼Œå† `JSON.parse()` |
| é”™è¯¯è°ƒè¯•     | `console.warn(xhr.responseText)` è¾“å‡ºåç«¯å†…å®¹           |

è¿™æ ·å°±ä¸ä¼šå†å‡ºç°â€œå¤„ç†å…¶å®æˆåŠŸï¼Œä½†å‰ç«¯è¯¯ä»¥ä¸ºå¤±è´¥â€çš„æƒ…å†µã€‚

å¦‚éœ€æˆ‘ä¸€æ¬¡æ€§æä¾›æœ€ç»ˆå‰ç«¯+åç«¯çš„ä¿®æ”¹æ•´åˆä»£ç ï¼Œä¹Ÿå¯ä»¥ç»§ç»­è¯´ä¸€å£°ã€‚

```
from fastapi import FastAPI, File, UploadFile, Form
from fastapi.responses import FileResponse, HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware
from fastapi import Query
from typing import List
from io import BytesIO
from convert_doc import convert_doc_to_pdf
from process import process_pdf_and_extract
from preview import generate_preview_image
from zip_util import zip_csvs
from uuid import uuid4
import shutil
import os


app = FastAPI()
app.mount("/static", StaticFiles(directory="static"), name="static")
app.mount("/outputs", StaticFiles(directory="outputs"), name="outputs")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_methods=["*"], allow_headers=["*"]
)

@app.get("/")
async def root():
    with open("static/index.html", "r", encoding="utf-8") as f:
        return HTMLResponse(content=f.read(), status_code=200)

@app.post("/preview/")
async def preview(
    file: UploadFile = File(...),
    top_cm: float = Form(...),
    bottom_cm: float = Form(...)
):
    ext = file.filename.rsplit(".", 1)[-1].lower()

    if ext in ("doc", "docx"):
        # Word å…ˆè½¬æ¢ä¸º PDFï¼Œå¾—åˆ°æ–‡ä»¶è·¯å¾„
        pdf_path = convert_doc_to_pdf(file)
        # ç›´æ¥ä¼ è·¯å¾„ç»™ generate_preview_image
        preview_path = generate_preview_image(pdf_path, top_cm, bottom_cm)
    else:
        # å¯¹ PDF ä¸Šä¼ æ–‡ä»¶
        file_bytes = await file.read()
        preview_path = generate_preview_image((file_bytes), top_cm, bottom_cm)

    return {"preview_path": preview_path}

from io import BytesIO

@app.post("/process_batch/")
async def process_batch(files: List[UploadFile] = File(...), top_cm: float = Form(...), bottom_cm: float = Form(...)):
    csv_paths = []

    for file in files:
        ext = file.filename.rsplit(".", 1)[-1].lower()

        if ext in ("doc", "docx"):
            # Word è½¬ PDF åè¯»å– PDF å†…å®¹
            pdf_path = convert_doc_to_pdf(file)
            with open(pdf_path, "rb") as f:
                pdf_bytes = f.read()
            csv_path = process_pdf_and_extract(BytesIO(pdf_bytes), top_cm, bottom_cm, filename=file.filename)
        else:
            # âœ… PDFï¼šç¼“å­˜æ–‡ä»¶å†…å®¹ç”¨äº BytesIO å¤„ç†
            file_bytes = await file.read()
            csv_path = process_pdf_and_extract(BytesIO(file_bytes), top_cm, bottom_cm, filename=file.filename)

        csv_paths.append(csv_path)

    if len(csv_paths) == 1:
        return {"path": csv_paths[0], "is_zip": False}
    else:
        zip_path = zip_csvs(csv_paths)
        return {"path": zip_path, "is_zip": True}


@app.get("/download/")
async def download(path: str = Query(..., alias="path")):
    return FileResponse(path, filename=os.path.basename(path))
```
```

    // å¤„ç†åŠŸèƒ½
    function processPDFs() {
      const files = fileInput.files;
      if (files.length === 0) return alert("è¯·ä¸Šä¼ PDFæ–‡ä»¶");
      
      const form = new FormData();
      for (let i = 0; i < files.length; i++) form.append("files", files[i]);
      form.append("top_cm", document.getElementById("top").value);
      form.append("bottom_cm", document.getElementById("bottom").value);

      const processBtn = document.querySelector('.btn-secondary[onclick="processPDFs()"]');
      processBtn.disabled = true;
      processBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> å¤„ç†ä¸­...';
      
      document.getElementById("progress-container").style.display = "block";
      document.getElementById("download-links").classList.add("hidden");

      const xhr = new XMLHttpRequest();
      xhr.open("POST", "/process_batch/", true);

      const bar = document.getElementById("progress-bar");
      const progressText = document.getElementById("progress-text");
      
      bar.value = 0;
      progressText.textContent = "å‡†å¤‡ä¸Šä¼ æ–‡ä»¶...";

      xhr.upload.onprogress = e => {
        if (e.lengthComputable) {
          const percent = Math.round((e.loaded / e.total) * 100);
          bar.value = percent;
          progressText.textContent = `ä¸Šä¼ ä¸­: ${percent}%`;
        }
      };

      xhr.onload = () => {
        try {
          const res = JSON.parse(xhr.responseText);
          document.getElementById("download-links").classList.remove("hidden");
          const csvLink = document.getElementById("csv-link");
          csvLink.href = `/download/?path=${encodeURIComponent(res.path)}`;
          
          if (res.is_zip) {
            document.getElementById("download-text").textContent = "ä¸‹è½½CSVå‹ç¼©åŒ…";
            csvLink.innerHTML = '<i class="fas fa-file-archive"></i> ä¸‹è½½CSVå‹ç¼©åŒ…';
          } else {
            document.getElementById("download-text").textContent = "ä¸‹è½½CSVæ–‡ä»¶";
            csvLink.innerHTML = '<i class="fas fa-file-csv"></i> ä¸‹è½½CSVæ–‡ä»¶';
          }
          
          progressText.textContent = "å¤„ç†å®Œæˆï¼";
          bar.value = 100;
        } catch (e) {
          progressText.textContent = "å¤„ç†å‡ºé”™ï¼";
          alert("å¤„ç†è¿‡ç¨‹ä¸­å‡ºé”™ï¼Œè¯·é‡è¯•");
        }
        
        processBtn.disabled = false;
        processBtn.innerHTML = '<i class="fas fa-play"></i> å¼€å§‹å¤„ç†PDFæ–‡ä»¶';
      };

      xhr.onerror = () => {
        progressText.textContent = "ç½‘ç»œé”™è¯¯ï¼";
        alert("ç½‘ç»œé”™è¯¯ï¼Œè¯·æ£€æŸ¥è¿æ¥åé‡è¯•");
        processBtn.disabled = false;
        processBtn.innerHTML = '<i class="fas fa-play"></i> å¼€å§‹å¤„ç†PDFæ–‡ä»¶';
      };

      xhr.send(form);
    }
  </script>
```
å‰ç«¯
```
<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PDF/Wordé¢„å¤„ç†å·¥å…·</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" />
  <style>
    .row {
      display: flex;
      gap: 20px;
    }

    .left-panel {
      flex: 2;
    }

    .right-panel {
      flex: 1.5;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #preview-img {
      max-width: 100%;
      max-height: 500px;
      border-radius: var(--border-radius);
      box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2); /* è°ƒæ•´é˜´å½± */
      border: 1px solid #eee;
      display: none;
    }

    :root {
      --primary-color: #4a6bff;
      --secondary-color: #6c757d;
      --success-color: #28a745;
      --danger-color: #dc3545;
      --light-color: #f8f9fa;
      --dark-color: #343a40;
      --border-radius: 8px;
      --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --transition: all 0.3s ease;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Roboto', sans-serif;
      line-height: 1.6;
      color: #333;
      background-color: #f5f7fa;
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }
    
    .container {
      background-color: white;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      padding: 30px;
      margin-top: 20px;
    }
    
    h1 {
      color: var(--primary-color);
      text-align: center;
      margin-bottom: 20px;
      font-weight: 500;
    }
    
    .section {
      margin-bottom: 15px;
      padding: 15px;
      border-radius: var(--border-radius);
      background-color: var(--light-color);
    }
    
    .section-title {
      font-size: 1.1rem;
      margin-bottom: 15px;
      color: var(--dark-color);
      display: flex;
      align-items: center;
    }
    
    .section-title i {
      margin-right: 10px;
      color: var(--primary-color);
    }
    
    .file-upload {
      border: 2px dashed #ccc;
      border-radius: var(--border-radius);
      padding: 30px;
      text-align: center;
      transition: var(--transition);
      margin-bottom: 15px;
      cursor: pointer;
    }
    
    .file-upload:hover {
      border-color: var(--primary-color);
      background-color: rgba(74, 107, 255, 0.05);
    }
    
    .file-upload.active {
      border-color: var(--success-color);
      background-color: rgba(40, 167, 69, 0.05);
    }
    
    #file-names {
      font-size: 0.9rem;
      color: var(--secondary-color);
      margin-top: 10px;
      word-break: break-all;
    }
    
    .form-group {
      margin-bottom: 20px;
    }
    
    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: var(--dark-color);
    }
    
    input[type="number"],
    input[type="file"] {
      width: 100%;
      padding: 10px 15px;
      border: 1px solid #ddd;
      border-radius: var(--border-radius);
      font-size: 1rem;
      transition: var(--transition);
    }
    
    input[type="number"]:focus,
    input[type="file"]:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(74, 107, 255, 0.2);
    }
    
    .input-group {
      display: flex;
      gap: 15px;
    }
    
    .input-group .form-group {
      flex: 1;
    }
    
    .btn {
      display: inline-block;
      padding: 12px 24px;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      transition: var(--transition);
      text-align: center;
      margin-right: 10px;
      margin-bottom: 10px;
    }
    
    .btn:hover {
      background-color: #3a5bef;
      transform: translateY(-2px);
    }
    
    .btn-secondary {
      background-color: var(--secondary-color);
    }
    
    .btn-secondary:hover {
      background-color: #5a6268;
    }
    
    .btn-block {
      display: block;
      width: 100%;
    }
    
    #preview-container {
      width: 400px;
      height: 465px;
      margin: 10px 20px;
      text-align: center;
    }
    
    #preview-img {
      max-width: 100%;
      max-height: 450px;
      border-radius: var(--border-radius);      
      border: 1px solid #eee;
      display: none;
    }
    
    .progress-container {
      margin: 25px 0;
    }
    
    progress {
      width: 100%;
      height: 10px;
      border-radius: 5px;
      margin-bottom: 10px;
    }
    
    progress::-webkit-progress-bar {
      background-color: #eee;
      border-radius: 5px;
    }
    
    progress::-webkit-progress-value {
      background-color: var(--primary-color);
      border-radius: 5px;
      transition: var(--transition);
    }
    
    #download-links {
      margin-top: 25px;
      text-align: center;
    }
    
    .download-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 12px 24px;
      background-color: var(--success-color);
      color: white;
      text-decoration: none;
      border-radius: var(--border-radius);
      transition: var(--transition);
    }
    
    .download-btn:hover {
      background-color: #218838;
      transform: translateY(-2px);
    }
    
    .download-btn i {
      margin-right: 8px;
    }
    
    .hidden {
      display: none !important;
    }
    

    @media (max-width: 768px) {
      .row {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1><i class="fas fa-file-pdf"></i> PDF/Wordé¢„å¤„ç†å·¥å…·</h1>
    
    <div class="row">
      <!-- å·¦ä¾§éƒ¨åˆ† -->
      <div class="left-panel">
        <div class="section">
          <h2 class="section-title"><i class="fas fa-cloud-upload-alt"></i> ä¸Šä¼ PDF/Wordæ–‡ä»¶</h2>
          <div class="file-upload" id="file-upload-area">
            <input type="file" id="pdf-input" multiple accept=".pdf,.doc,.docx" hidden>
            <p><i class="fas fa-upload"></i> ç‚¹å‡»æˆ–æ‹–æ”¾PDF/Wordæ–‡ä»¶åˆ°æ­¤å¤„</p>
            <p class="text-muted">æ”¯æŒä¸€æ¬¡æ€§å¤šæ–‡ä»¶ä¸Šä¼ </p>
          </div>
          <p id="file-names" class="text-muted"></p>
        </div>
        
        <div class="section">
          <h2 class="section-title"><i class="fas fa-cut"></i> è£å‰ªè®¾ç½® <p class="text-muted">ï¼ˆè¯·æ ¹æ®éœ€è¦è£é™¤é¡µçœ‰é¡µå°¾ï¼‰</p> </h2>
          
          <div class="input-group">
            <div class="form-group">
              <label for="top"><i class="fas fa-arrow-up"></i> ä¸Šï¼ˆé¡µçœ‰ï¼‰è£å‰ªè·ç¦» (cm)</label>
              <input type="number" id="top" value="2.5" step="0.1" min="0">
            </div>
            <div class="form-group">
              <label for="bottom"><i class="fas fa-arrow-down"></i> ä¸‹ï¼ˆé¡µå°¾ï¼‰è£å‰ªè·ç¦» (cm)</label>
              <input type="number" id="bottom" value="2.5" step="0.1" min="0">
            </div>
          </div>
        </div>
        
        <div class="section">
          <h2 class="section-title"><i class="fas fa-cog"></i> å¤„ç†</h2>
          <div class="progress-container" id="progress-container" style="display: none;">
            <progress id="progress-bar" value="0" max="100"></progress>
            <p class="text-muted" id="progress-text">å¤„ç†ä¸­ï¼Œè¯·ç¨å€™...</p>
          </div>
          <div class="row" style="display: flex; gap: 10px;">
            <button class="btn btn-secondary" style="flex: 1;" onclick="previewPDF()">
              <i class="fas fa-image"></i> é¢„è§ˆå‰ªè£æ•ˆæœ
            </button>
            <button class="btn btn-secondary" style="flex: 1;" onclick="processPDFs()">
              <i class="fas fa-play"></i> å¼€å§‹å¤„ç†æ–‡ä»¶
            </button>
          </div>
        </div>
        
        
      </div>
      
      <!-- å³ä¾§éƒ¨åˆ† -->
      <div class="right-panel">
        <div class="section">
          <h2 class="section-title"><i class="fas fa-eye"></i> é¢„è§ˆ(å¤šæ–‡ä»¶æš‚ä¸æ”¯æŒ)</h2>
          <div id="preview-container">

            <img id="preview-img" style="margin-top: 15px;" />
          </div>
        </div>
        <div id="download-links" class="hidden">          
          <a id="csv-link" href="#" class="download-btn">
            <i class="fas fa-file-csv"></i> <span id="download-text">ä¸‹è½½CSVæ–‡ä»¶</span>
          </a>
        </div>
      </div>
    </div>
  </div>

  <script>
    // æ–‡ä»¶ä¸Šä¼ åŒºåŸŸäº¤äº’
    const fileInput = document.getElementById("pdf-input");
    const fileUploadArea = document.getElementById("file-upload-area");
    
    fileUploadArea.addEventListener("click", () => {
      fileInput.click();
    });
    
    fileInput.addEventListener("change", () => {
      const names = Array.from(fileInput.files).map(f => f.name).join("ï¼›");
      document.getElementById("file-names").textContent = `å·²é€‰æ‹© ${fileInput.files.length} ä¸ªæ–‡ä»¶`;
      fileUploadArea.classList.add("active");
      
      // æ˜¾ç¤ºå‰å‡ ä¸ªæ–‡ä»¶å
      if (fileInput.files.length > 0) {
        const sampleNames = Array.from(fileInput.files)
          .slice(0, 3)
          .map(f => f.name)
          .join(", ");
        document.getElementById("file-names").textContent = 
          `å·²é€‰æ‹© ${fileInput.files.length} ä¸ªæ–‡ä»¶ (ç¤ºä¾‹: ${sampleNames}${fileInput.files.length > 3 ? "..." : ""})`;
      }
    });
    
    // æ‹–æ”¾åŠŸèƒ½
    fileUploadArea.addEventListener("dragover", (e) => {
      e.preventDefault();
      fileUploadArea.classList.add("active");
    });
    
    fileUploadArea.addEventListener("dragleave", () => {
      fileUploadArea.classList.remove("active");
    });
    
    fileUploadArea.addEventListener("drop", (e) => {
      e.preventDefault();
      fileUploadArea.classList.remove("active");
      
      if (e.dataTransfer.files.length) {
        fileInput.files = e.dataTransfer.files;
        const event = new Event("change");
        fileInput.dispatchEvent(event);
      }
    });
    
    // é¢„è§ˆåŠŸèƒ½
    function previewPDF() {
      const file = fileInput.files[0];
      if (!file) return alert("è¯·é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶è¿›è¡Œé¢„è§ˆ");
      
      const form = new FormData();
      form.append("file", file);
      form.append("top_cm", document.getElementById("top").value);
      form.append("bottom_cm", document.getElementById("bottom").value);

      const previewBtn = document.querySelector('.btn-secondary[onclick="previewPDF()"]');
      previewBtn.disabled = true;
      previewBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> ç”Ÿæˆé¢„è§ˆ...';
      
      fetch("/preview/", { method: "POST", body: form })
        .then(res => res.json())
        .then(data => {
          const img = document.getElementById("preview-img");
          img.src = "/" + encodeURIComponent(data.preview_path);
          img.style.display = "block";
          previewBtn.disabled = false;
          previewBtn.innerHTML = '<i class="fas fa-image"></i> é¢„è§ˆå‰ªè£æ•ˆæœ';
        })
        .catch(() => {
          previewBtn.disabled = false;
          previewBtn.innerHTML = '<i class="fas fa-image"></i> é¢„è§ˆå‰ªè£æ•ˆæœ';
          alert("é¢„è§ˆç”Ÿæˆå¤±è´¥ï¼Œè¯·é‡è¯•");
        });
    }
    
    // å¤„ç†åŠŸèƒ½
    function processPDFs() {
      const files = fileInput.files;
      if (files.length === 0) return alert("è¯·ä¸Šä¼ PDFæ–‡ä»¶");
      
      const form = new FormData();
      for (let i = 0; i < files.length; i++) form.append("files", files[i]);
      form.append("top_cm", document.getElementById("top").value);
      form.append("bottom_cm", document.getElementById("bottom").value);

      const processBtn = document.querySelector('.btn-secondary[onclick="processPDFs()"]');
      processBtn.disabled = true;
      processBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> å¤„ç†ä¸­...';
      
      document.getElementById("progress-container").style.display = "block";
      document.getElementById("download-links").classList.add("hidden");

      const xhr = new XMLHttpRequest();
      xhr.open("POST", "/process_batch/", true);

      const bar = document.getElementById("progress-bar");
      const progressText = document.getElementById("progress-text");
      
      bar.value = 0;
      progressText.textContent = "å‡†å¤‡ä¸Šä¼ æ–‡ä»¶...";

      xhr.upload.onprogress = e => {
        if (e.lengthComputable) {
          const percent = Math.round((e.loaded / e.total) * 100);
          bar.value = percent;
          progressText.textContent = `ä¸Šä¼ ä¸­: ${percent}%`;
        }
      };

      xhr.onload = () => {
        try {
          const res = JSON.parse(xhr.responseText);
          document.getElementById("download-links").classList.remove("hidden");
          const csvLink = document.getElementById("csv-link");
          csvLink.href = `/download/?path=${encodeURIComponent(res.path)}`;
          
          if (res.is_zip) {
            document.getElementById("download-text").textContent = "ä¸‹è½½CSVå‹ç¼©åŒ…";
            csvLink.innerHTML = '<i class="fas fa-file-archive"></i> ä¸‹è½½CSVå‹ç¼©åŒ…';
          } else {
            document.getElementById("download-text").textContent = "ä¸‹è½½CSVæ–‡ä»¶";
            csvLink.innerHTML = '<i class="fas fa-file-csv"></i> ä¸‹è½½CSVæ–‡ä»¶';
          }
          
          progressText.textContent = "å¤„ç†å®Œæˆï¼";
          bar.value = 100;
        } catch (e) {
          progressText.textContent = "å¤„ç†å‡ºé”™ï¼";
          alert("å¤„ç†è¿‡ç¨‹ä¸­å‡ºé”™ï¼Œè¯·é‡è¯•");
        }
        
        processBtn.disabled = false;
        processBtn.innerHTML = '<i class="fas fa-play"></i> å¼€å§‹å¤„ç†PDFæ–‡ä»¶';
      };

      xhr.onerror = () => {
        progressText.textContent = "ç½‘ç»œé”™è¯¯ï¼";
        alert("ç½‘ç»œé”™è¯¯ï¼Œè¯·æ£€æŸ¥è¿æ¥åé‡è¯•");
        processBtn.disabled = false;
        processBtn.innerHTML = '<i class="fas fa-play"></i> å¼€å§‹å¤„ç†PDFæ–‡ä»¶';
      };

      xhr.send(form);
    }
  </script>
</body>
</html>
```
```
from fastapi.responses import FileResponse, JSONResponse

@app.post("/process_batch/")
async def process_batch(files: List[UploadFile] = File(...), top_cm: float = Form(...), bottom_cm: float = Form(...)):
    csv_paths = []
    errors = []

    for file in files:
        try:
            ext = file.filename.rsplit(".", 1)[-1].lower()

            if ext in ("doc", "docx"):
                pdf_path = convert_doc_to_pdf(file)
                with open(pdf_path, "rb") as f:
                    pdf_bytes = f.read()
                csv_path = process_pdf_and_extract(BytesIO(pdf_bytes), top_cm, bottom_cm, filename=file.filename)
            elif ext == "pdf":
                file_bytes = await file.read()
                csv_path = process_pdf_and_extract(BytesIO(file_bytes), top_cm, bottom_cm, filename=file.filename)
            else:
                raise ValueError(f"Unsupported file type: {file.filename}")

            csv_paths.append(csv_path)
        except Exception as e:
            print(f"âŒ Error processing {file.filename}: {e}")
            errors.append(file.filename)

    if not csv_paths:
        return JSONResponse(status_code=500, content={"message": "All files failed", "errors": errors})

    if len(csv_paths) == 1:
        return FileResponse(csv_paths[0], filename=os.path.basename(csv_paths[0]))
    else:
        zip_path = zip_csvs(csv_paths)
        return FileResponse(zip_path, filename=os.path.basename(zip_path))


```
```
from fastapi.responses import JSONResponse

@app.post("/process_batch")
async def process_batch(
    files: List[UploadFile] = File(...),
    top_cm: float = Form(0),
    bottom_cm: float = Form(0)
):
    output_dir = "processed"
    os.makedirs(output_dir, exist_ok=True)

    results = []
    errors = []

    for file in files:
        filename = unquote(file.filename)
        ext = filename.split(".")[-1].lower()
        try:
            if ext in ("doc", "docx"):
                pdf_path = convert_doc_to_pdf(file)
                with open(pdf_path, "rb") as f:
                    pdf_bytes = f.read()
                csv_path = process_pdf_and_extract(BytesIO(pdf_bytes), top_cm, bottom_cm, filename=filename)
            elif ext == "pdf":
                pdf_bytes = await file.read()
                csv_path = process_pdf_and_extract(BytesIO(pdf_bytes), top_cm, bottom_cm, filename=filename)
            else:
                raise ValueError("Unsupported file type")
            results.append(csv_path)
        except Exception as e:
            print(f"âŒ Error processing {filename}: {e}")
            errors.append(filename)
            continue

    if not results:
        return JSONResponse(status_code=500, content={"message": "All files failed to process", "errors": errors})

    # ç”Ÿæˆç»“æœ ZIP
    if len(results) == 1:
        return FileResponse(results[0], filename=os.path.basename(results[0]))
    else:
        zip_path = create_zip(results, output_dir)
        return FileResponse(zip_path, filename=os.path.basename(zip_path))


```
è¿™ä¸ªé”™è¯¯ä¿¡æ¯æ¸…æ™°åœ°æŒ‡å‡ºäº†ä½ çš„é—®é¢˜å‡ºåœ¨è¿™é‡Œï¼š

```
TypeError: bad stream: type(stream)=<class 'str'>
```

### é”™è¯¯æ ¹å› ï¼š

ä½ è°ƒç”¨äº† `fitz.open(stream=..., filetype="pdf")`ï¼Œä½†ä¼ å…¥çš„ `stream` å®é™…æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼ˆstr ç±»å‹ï¼‰ï¼Œè€Œä¸æ˜¯æœŸæœ›çš„ `bytes`ã€`BytesIO` æˆ–å¯è¯»å–æµï¼ˆæ¯”å¦‚æ–‡ä»¶å¯¹è±¡ï¼‰ã€‚

---

### é—®é¢˜å‡ºç°åœ¨ä½ è°ƒç”¨ `process_pdf_and_extract()` çš„æ–¹å¼ï¼š

åœ¨ `app.py` ä¸­ç¬¬ 63 è¡Œï¼š

```python
csv_path = process_pdf_and_extract(pdf_path, top_cm, bottom_cm)
```

è¿™é‡Œ `pdf_path` æ˜¯å­—ç¬¦ä¸²è·¯å¾„ï¼Œè€Œä½ åœ¨ `process_pdf_and_extract()` ä¸­è°ƒç”¨çš„æ˜¯ï¼š

```python
pdf = fitz.open(stream=file.read() if hasattr(file, "read") else file, filetype="pdf")
```

å½“ä¼ å…¥çš„æ˜¯å­—ç¬¦ä¸² `pdf_path`ï¼Œå°±èµ°åˆ°äº† `else file`ï¼Œå³ `fitz.open(stream=pdf_path, filetype="pdf")`ï¼Œè€Œ `fitz.open()` ä¸æ”¯æŒå­—ç¬¦ä¸²ä½œä¸º `stream` å‚æ•°ã€‚

---

### âœ… æ­£ç¡®åšæ³•ï¼š

ä½ åº”è¯¥æ”¹ä¸ºï¼š

```python
pdf = fitz.open(file)  # å¦‚æœæ˜¯æ–‡ä»¶è·¯å¾„ï¼Œç›´æ¥ä¼ è·¯å¾„ï¼Œfitz ä¼šè‡ªåŠ¨è¯†åˆ«
```

æˆ–è€…æ›´å¥å£®ï¼š

```python
if hasattr(file, "read"):  # æ˜¯ BytesIO æˆ– UploadFile
    pdf = fitz.open(stream=file.read(), filetype="pdf")
else:  # æ˜¯è·¯å¾„å­—ç¬¦ä¸²
    pdf = fitz.open(file)
```

---

### âœ… æ¨èä¿®å¤æ–¹æ¡ˆï¼š

åœ¨ `process.py` ä¸­ `process_pdf_and_extract()` å‡½æ•°é‡Œï¼Œä¿®æ”¹å¦‚ä¸‹ï¼š

```python
import fitz  # PyMuPDF

def process_pdf_and_extract(file, top_cm, bottom_cm, filename=None):
    # å¤„ç†ä¼ å…¥çš„ file å‚æ•°ï¼šå¯èƒ½æ˜¯ BytesIOã€UploadFile æˆ– str è·¯å¾„
    if hasattr(file, "read"):
        pdf = fitz.open(stream=file.read(), filetype="pdf")
    elif isinstance(file, (bytes, bytearray)):
        pdf = fitz.open(stream=file, filetype="pdf")
    elif isinstance(file, str):
        pdf = fitz.open(file)  # æ˜¯ä¸€ä¸ª PDF æ–‡ä»¶è·¯å¾„
    else:
        raise TypeError(f"Unsupported file input type: {type(file)}")

    # åç»­ä½ çš„é€»è¾‘ä¿æŒä¸å˜...
```

---

### âœ… è¡¥å……å»ºè®®ï¼š

ä½ åœ¨ä¸Šä¼  Word æ–‡ä»¶æ—¶ï¼Œç”¨ `convert_doc_to_pdf(file)` åªè¿”å›äº† PDF è·¯å¾„ï¼ˆstrï¼‰ï¼Œä½† `process_pdf_and_extract()` æœŸæœ›çš„æ˜¯ BytesIO æˆ–å¯è¯»å–å¯¹è±¡ã€‚è¿™ä¸¤å¤„çš„å¤„ç†æ–¹å¼åº”è¯¥ç»Ÿä¸€ï¼Œæ¯”å¦‚å°† Word è½¬ PDF åè¯»å–å†…å®¹ä¸º BytesIO ä¼ å…¥ï¼Œæˆ–è€…ç»Ÿä¸€éƒ½è®© `process_pdf_and_extract()` æ”¯æŒæ–‡ä»¶è·¯å¾„ã€‚

---

### âœ… ç»Ÿä¸€å¤„ç†å»ºè®®ï¼ˆæ¨èï¼‰ï¼š

åœ¨ `app.py` ä¸­ä¿®æ”¹ï¼š

```python
if ext in ("doc", "docx"):
    # Word è½¬ PDF åè¯»å– PDF å†…å®¹
    pdf_path = convert_doc_to_pdf(file)
    with open(pdf_path, "rb") as f:
        pdf_bytes = f.read()
    csv_path = process_pdf_and_extract(BytesIO(pdf_bytes), top_cm, bottom_cm, filename=file.filename)
```

è¿™æ ·ä½ å°±ä¸ç”¨ä¿®æ”¹ `process_pdf_and_extract()` çš„å®ç°æ–¹å¼äº†ï¼Œä¿æŒæ‰€æœ‰ä¼ å…¥éƒ½æ˜¯ BytesIOï¼Œä¸€è‡´æ€§æ›´å¥½ã€‚

---

å¦‚éœ€æˆ‘å¸®ä½ é‡æ„å®Œæ•´ä»£ç æˆ–æ¨¡å—ç»“æ„ï¼Œä¹Ÿå¯ä»¥ç»§ç»­å‘æˆ‘ã€‚

```
ERROR:    Exception in ASGI application
Traceback (most recent call last):
  File "/usr/local/lib/python3.9/site-packages/uvicorn/protocols/http/h11_impl.py", line 403, in run_asgi
    result = await app(  # type: ignore[func-returns-value]
  File "/usr/local/lib/python3.9/site-packages/uvicorn/middleware/proxy_headers.py", line 60, in __call__
    return await self.app(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/fastapi/applications.py", line 1054, in __call__
    await super().__call__(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/applications.py", line 112, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/middleware/errors.py", line 187, in __call__
    raise exc
  File "/usr/local/lib/python3.9/site-packages/starlette/middleware/errors.py", line 165, in __call__
    await self.app(scope, receive, _send)
  File "/usr/local/lib/python3.9/site-packages/starlette/middleware/cors.py", line 93, in __call__
    await self.simple_response(scope, receive, send, request_headers=headers)
  File "/usr/local/lib/python3.9/site-packages/starlette/middleware/cors.py", line 144, in simple_response
    await self.app(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/middleware/exceptions.py", line 62, in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/usr/local/lib/python3.9/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/usr/local/lib/python3.9/site-packages/starlette/routing.py", line 714, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/routing.py", line 734, in app
    await route.handle(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/routing.py", line 288, in handle
    await self.app(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/routing.py", line 76, in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/usr/local/lib/python3.9/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/usr/local/lib/python3.9/site-packages/starlette/routing.py", line 73, in app
    response = await f(request)
  File "/usr/local/lib/python3.9/site-packages/fastapi/routing.py", line 301, in app
    raw_response = await run_endpoint_function(
  File "/usr/local/lib/python3.9/site-packages/fastapi/routing.py", line 212, in run_endpoint_function
    return await dependant.call(**values)
  File "/app/app.py", line 63, in process_batch
    csv_path = process_pdf_and_extract(pdf_path, top_cm, bottom_cm)
  File "/app/process.py", line 11, in process_pdf_and_extract
    pdf = fitz.open(stream=file.read() if hasattr(file, "read") else file, filetype="pdf")
  File "/usr/local/lib/python3.9/site-packages/pymupdf/__init__.py", line 2926, in __init__
    raise TypeError(f"bad stream: {type(stream)=}.")
TypeError: bad stream: type(stream)=<class 'str'>.
```
```
# process.py
import os
import fitz  # PyMuPDF
import csv
import re
from uuid import uuid4
from convert_doc import convert_doc_to_pdf
from io import BytesIO

os.makedirs("outputs", exist_ok=True)

def process_pdf_and_extract(file, top_cm, bottom_cm):
    filename = file.filename.rsplit(".", 1)[0]

    # åˆ¤æ–­æ˜¯å¦æ˜¯ Word æ–‡ä»¶
    ext = file.filename.rsplit(".", 1)[-1].lower()
    if ext in ("doc", "docx"):
        pdf_path = convert_doc_to_pdf(file)
        doc = fitz.open(pdf_path)
    else:
        # PDF æ–‡ä»¶ï¼šä½¿ç”¨ file.file.read()
        pdf_bytes = file.file.read()
        doc = fitz.open(stream=pdf_bytes, filetype="pdf")

    csv_path = f"outputs/{filename}.csv"
    heading_pattern = re.compile(r'^(\d+(\.\d+)*)(\s+)(.+)')  # 1ã€1.1ã€1.1.1 æ ‡é¢˜
    current_heading = None
    content_dict = {}

    for page in doc:
        rect = page.rect
        top = top_cm * 28.35
        bottom = bottom_cm * 28.35
        clip = fitz.Rect(rect.x0, rect.y0 + top, rect.x1, rect.y1 - bottom)
        blocks = page.get_text("blocks", clip=clip)
        sorted_blocks = sorted(blocks, key=lambda b: (b[1], b[0]))  # ä»ä¸Šåˆ°ä¸‹æ’åº

        for block in sorted_blocks:
            text = block[4].strip()
            if not text:
                continue
            match = heading_pattern.match(text)
            if match:
                current_heading = f"{match.group(1)} {match.group(4).strip()}"
                content_dict[current_heading] = ""
            elif current_heading:
                content_dict[current_heading] += text + " "

    with open(csv_path, "w", newline="", encoding="utf-8-sig") as f:
        writer = csv.writer(f)
        for heading, content in content_dict.items():
            writer.writerow([heading, content.strip()])

    return csv_path
```
