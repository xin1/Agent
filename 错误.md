你描述的现象是：
**上传 PDF 和 Word 文件混合后，后端处理成功（CSV 已生成），但前端 `xhr.onload` 中 JSON 解析失败，显示“处理出错！”**

这说明：
✅ 后端没有真正崩溃，
❌ 但返回的 `xhr.responseText` **不是标准 JSON**，导致这句报错：

```js
const res = JSON.parse(xhr.responseText); // ❌ 失败
```

---

## ✅ 问题本质

FastAPI 默认在异常时返回 **HTML 错误页**，**而你上传 Word + PDF 的组合时可能触发了某种异常或日志输出**，但处理流程本身没炸，只是返回内容不是 JSON。

---

## ✅ 解决方法：修改 FastAPI，确保始终返回标准 JSON（关键）

请对 `/process_batch/` 添加完整的异常处理逻辑，确保**无论成功还是失败，返回都是 JSONResponse**：

### 🔧 完整修复版 `/process_batch/`

```python
from fastapi.responses import JSONResponse
from fastapi import Request
import traceback

@app.post("/process_batch/")
async def process_batch(
    files: List[UploadFile] = File(...),
    top_cm: float = Form(...),
    bottom_cm: float = Form(...)
):
    try:
        csv_paths = []

        for file in files:
            ext = file.filename.rsplit(".", 1)[-1].lower()

            if ext in ("doc", "docx"):
                pdf_path = convert_doc_to_pdf(file)
                with open(pdf_path, "rb") as f:
                    pdf_bytes = f.read()
                csv_path = process_pdf_and_extract(BytesIO(pdf_bytes), top_cm, bottom_cm, filename=file.filename)
            else:
                file_bytes = await file.read()
                csv_path = process_pdf_and_extract(BytesIO(file_bytes), top_cm, bottom_cm, filename=file.filename)

            csv_paths.append(csv_path)

        if len(csv_paths) == 1:
            return JSONResponse(content={"path": csv_paths[0], "is_zip": False})
        else:
            zip_path = zip_csvs(csv_paths)
            return JSONResponse(content={"path": zip_path, "is_zip": True})

    except Exception as e:
        # 打印错误日志方便调试
        traceback.print_exc()
        return JSONResponse(
            status_code=500,
            content={"error": "文档处理失败", "detail": str(e)}
        )
```

---

## ✅ 建议前端加上调试打印

修改前端 `xhr.onload` 的 `catch` 块，增加调试输出：

```js
xhr.onload = () => {
  try {
    const res = JSON.parse(xhr.responseText);  // ❌ 失败点
    document.getElementById("download-links").classList.remove("hidden");
    const csvLink = document.getElementById("csv-link");
    csvLink.href = `/download/?path=${encodeURIComponent(res.path)}`;
    
    if (res.is_zip) {
      document.getElementById("download-text").textContent = "下载CSV压缩包";
      csvLink.innerHTML = '<i class="fas fa-file-archive"></i> 下载CSV压缩包';
    } else {
      document.getElementById("download-text").textContent = "下载CSV文件";
      csvLink.innerHTML = '<i class="fas fa-file-csv"></i> 下载CSV文件';
    }

    progressText.textContent = "处理完成！";
    bar.value = 100;

  } catch (e) {
    console.warn("返回内容无法解析为 JSON：", xhr.responseText);
    progressText.textContent = "处理出错！";
    alert("处理过程中出错，请重试");
  }

  processBtn.disabled = false;
  processBtn.innerHTML = '<i class="fas fa-play"></i> 开始处理PDF文件';
};
```

---

## ✅ 推荐调试步骤

1. **在前端打印 `xhr.responseText`**，查看是否是 HTML 错误页。
2. **确保后端 `.read()` 和 `BytesIO()` 都写对了，Word 和 PDF 的流程一致。**
3. **看一下 convert\_doc\_to\_pdf 是否抛错却没中断流程。**

---

如果你愿意，我也可以帮你检查 `convert_doc_to_pdf()` 是否有边界异常未处理，或者一次性打包前后端修复版。要不要我一起给？

感谢你补充了完整的前端 `processPDFs()` 代码。

你之前提到的问题是：

> 实际后端处理成功、文件已生成，但前端弹出“处理过程中出错”，说明 **前端 `xhr.onload` 的 JSON 解析失败了**。

---

## ✅ 问题分析

在你这段代码里，核心逻辑是：

```javascript
xhr.onload = () => {
  try {
    const res = JSON.parse(xhr.responseText); // 如果不是 JSON，会进入 catch
    ...
  } catch (e) {
    progressText.textContent = "处理出错！";
    alert("处理过程中出错，请重试");
  }
};
```

⚠️ **一旦后端返回的不是纯 JSON（比如 HTML 报错页面或日志），就会触发 catch，前端以为“出错”**，哪怕实际文件已生成。

---

## ✅ 正确做法：先判断 `xhr.status` 和 `Content-Type` 类型

你可以这样修改 `xhr.onload`，确保只有真出错才弹窗：

### ✅ **改进版 `xhr.onload`：**

```javascript
xhr.onload = () => {
  const contentType = xhr.getResponseHeader("Content-Type") || "";
  
  if (xhr.status === 200 && contentType.includes("application/json")) {
    try {
      const res = JSON.parse(xhr.responseText);

      document.getElementById("download-links").classList.remove("hidden");
      const csvLink = document.getElementById("csv-link");
      csvLink.href = `/download/?path=${encodeURIComponent(res.path)}`;
      
      if (res.is_zip) {
        document.getElementById("download-text").textContent = "下载CSV压缩包";
        csvLink.innerHTML = '<i class="fas fa-file-archive"></i> 下载CSV压缩包';
      } else {
        document.getElementById("download-text").textContent = "下载CSV文件";
        csvLink.innerHTML = '<i class="fas fa-file-csv"></i> 下载CSV文件';
      }
      
      progressText.textContent = "处理完成！";
      bar.value = 100;
    } catch (e) {
      progressText.textContent = "结果解析失败！";
      alert("处理完成，但返回结果无法解析，请检查后端是否返回了JSON");
    }
  } else {
    progressText.textContent = "处理出错！";
    alert("处理过程中出错，返回状态码：" + xhr.status);
    console.warn("响应内容:", xhr.responseText);
  }

  processBtn.disabled = false;
  processBtn.innerHTML = '<i class="fas fa-play"></i> 开始处理PDF文件';
};
```

---

## ✅ 后端建议：确保返回是 JSON 格式

```python
from fastapi.responses import JSONResponse

return JSONResponse(content={"path": zip_path, "is_zip": True})
```

或者确保异常时返回明确的 JSON，而不是 HTML：

```python
return JSONResponse(status_code=500, content={"error": "Something went wrong"})
```

---

## ✅ 总结

| 问题                      | 解决方案                                |
| ----------------------- | ----------------------------------- |
| response 不是 JSON 导致前端报错 | 判断 `Content-Type` 后再 `JSON.parse()` |
| 后端错误返回了 HTML            | 后端统一用 JSON 返回错误                     |
| 文件其实已生成，但前端误判失败         | 前端不要盲目 `try JSON.parse()`，应检查类型     |

如你需要我帮你改后端返回逻辑，也可以贴上 `/process_batch/` 的 FastAPI 路由逻辑。

非常好，你的 `/process_batch/` 路由逻辑已经是成功返回 JSON 格式数据的：

```python
return {"path": csv_paths[0], "is_zip": False}
```

但你在 **没有指定响应类型**，FastAPI 默认是 `application/json`，理论上前端能正常解析，但**在某些异常或错误时，返回的可能是 HTML 报错页面**，前端 `JSON.parse()` 就炸了。

---

## ✅ 建议一：明确指定返回类型为 JSON

你可以明确设置响应类型，确保浏览器不误判：

```python
from fastapi.responses import JSONResponse

# 在单文件返回时：
return JSONResponse(content={"path": csv_paths[0], "is_zip": False})

# 多文件压缩时：
return JSONResponse(content={"path": zip_path, "is_zip": True})
```

---

## ✅ 建议二：异常统一返回 JSON（避免 HTML 报错）

给 `process_batch()` 加一个统一异常捕获（可选增强）：

```python
from fastapi.responses import JSONResponse
from fastapi import Request
import traceback

@app.post("/process_batch/")
async def process_batch(
    files: List[UploadFile] = File(...),
    top_cm: float = Form(...),
    bottom_cm: float = Form(...)
):
    try:
        csv_paths = []

        for file in files:
            ext = file.filename.rsplit(".", 1)[-1].lower()

            if ext in ("doc", "docx"):
                pdf_path = convert_doc_to_pdf(file)
                with open(pdf_path, "rb") as f:
                    pdf_bytes = f.read()
                csv_path = process_pdf_and_extract(BytesIO(pdf_bytes), top_cm, bottom_cm, filename=file.filename)
            else:
                file_bytes = await file.read()
                csv_path = process_pdf_and_extract(BytesIO(file_bytes), top_cm, bottom_cm, filename=file.filename)

            csv_paths.append(csv_path)

        if len(csv_paths) == 1:
            return JSONResponse(content={"path": csv_paths[0], "is_zip": False})
        else:
            zip_path = zip_csvs(csv_paths)
            return JSONResponse(content={"path": zip_path, "is_zip": True})

    except Exception as e:
        traceback.print_exc()
        return JSONResponse(status_code=500, content={"error": "处理失败", "detail": str(e)})
```

这样即使处理失败，前端也能收到标准 JSON，`xhr.onload` 的 JSON.parse 就不会炸。

---

## ✅ 前端 + 后端联合修复总结

| 方面       | 建议                                                |
| -------- | ------------------------------------------------- |
| 后端正常返回   | 使用 `JSONResponse(content={...})` 明确响应类型           |
| 后端异常处理   | 捕获异常并返回标准 JSON（非 HTML 报错页）                        |
| 前端 JS 解析 | 检查 `xhr.status` 和 `Content-Type`，再 `JSON.parse()` |
| 错误调试     | `console.warn(xhr.responseText)` 输出后端内容           |

这样就不会再出现“处理其实成功，但前端误以为失败”的情况。

如需我一次性提供最终前端+后端的修改整合代码，也可以继续说一声。

```
from fastapi import FastAPI, File, UploadFile, Form
from fastapi.responses import FileResponse, HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware
from fastapi import Query
from typing import List
from io import BytesIO
from convert_doc import convert_doc_to_pdf
from process import process_pdf_and_extract
from preview import generate_preview_image
from zip_util import zip_csvs
from uuid import uuid4
import shutil
import os


app = FastAPI()
app.mount("/static", StaticFiles(directory="static"), name="static")
app.mount("/outputs", StaticFiles(directory="outputs"), name="outputs")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_methods=["*"], allow_headers=["*"]
)

@app.get("/")
async def root():
    with open("static/index.html", "r", encoding="utf-8") as f:
        return HTMLResponse(content=f.read(), status_code=200)

@app.post("/preview/")
async def preview(
    file: UploadFile = File(...),
    top_cm: float = Form(...),
    bottom_cm: float = Form(...)
):
    ext = file.filename.rsplit(".", 1)[-1].lower()

    if ext in ("doc", "docx"):
        # Word 先转换为 PDF，得到文件路径
        pdf_path = convert_doc_to_pdf(file)
        # 直接传路径给 generate_preview_image
        preview_path = generate_preview_image(pdf_path, top_cm, bottom_cm)
    else:
        # 对 PDF 上传文件
        file_bytes = await file.read()
        preview_path = generate_preview_image((file_bytes), top_cm, bottom_cm)

    return {"preview_path": preview_path}

from io import BytesIO

@app.post("/process_batch/")
async def process_batch(files: List[UploadFile] = File(...), top_cm: float = Form(...), bottom_cm: float = Form(...)):
    csv_paths = []

    for file in files:
        ext = file.filename.rsplit(".", 1)[-1].lower()

        if ext in ("doc", "docx"):
            # Word 转 PDF 后读取 PDF 内容
            pdf_path = convert_doc_to_pdf(file)
            with open(pdf_path, "rb") as f:
                pdf_bytes = f.read()
            csv_path = process_pdf_and_extract(BytesIO(pdf_bytes), top_cm, bottom_cm, filename=file.filename)
        else:
            # ✅ PDF：缓存文件内容用于 BytesIO 处理
            file_bytes = await file.read()
            csv_path = process_pdf_and_extract(BytesIO(file_bytes), top_cm, bottom_cm, filename=file.filename)

        csv_paths.append(csv_path)

    if len(csv_paths) == 1:
        return {"path": csv_paths[0], "is_zip": False}
    else:
        zip_path = zip_csvs(csv_paths)
        return {"path": zip_path, "is_zip": True}


@app.get("/download/")
async def download(path: str = Query(..., alias="path")):
    return FileResponse(path, filename=os.path.basename(path))
```
```

    // 处理功能
    function processPDFs() {
      const files = fileInput.files;
      if (files.length === 0) return alert("请上传PDF文件");
      
      const form = new FormData();
      for (let i = 0; i < files.length; i++) form.append("files", files[i]);
      form.append("top_cm", document.getElementById("top").value);
      form.append("bottom_cm", document.getElementById("bottom").value);

      const processBtn = document.querySelector('.btn-secondary[onclick="processPDFs()"]');
      processBtn.disabled = true;
      processBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 处理中...';
      
      document.getElementById("progress-container").style.display = "block";
      document.getElementById("download-links").classList.add("hidden");

      const xhr = new XMLHttpRequest();
      xhr.open("POST", "/process_batch/", true);

      const bar = document.getElementById("progress-bar");
      const progressText = document.getElementById("progress-text");
      
      bar.value = 0;
      progressText.textContent = "准备上传文件...";

      xhr.upload.onprogress = e => {
        if (e.lengthComputable) {
          const percent = Math.round((e.loaded / e.total) * 100);
          bar.value = percent;
          progressText.textContent = `上传中: ${percent}%`;
        }
      };

      xhr.onload = () => {
        try {
          const res = JSON.parse(xhr.responseText);
          document.getElementById("download-links").classList.remove("hidden");
          const csvLink = document.getElementById("csv-link");
          csvLink.href = `/download/?path=${encodeURIComponent(res.path)}`;
          
          if (res.is_zip) {
            document.getElementById("download-text").textContent = "下载CSV压缩包";
            csvLink.innerHTML = '<i class="fas fa-file-archive"></i> 下载CSV压缩包';
          } else {
            document.getElementById("download-text").textContent = "下载CSV文件";
            csvLink.innerHTML = '<i class="fas fa-file-csv"></i> 下载CSV文件';
          }
          
          progressText.textContent = "处理完成！";
          bar.value = 100;
        } catch (e) {
          progressText.textContent = "处理出错！";
          alert("处理过程中出错，请重试");
        }
        
        processBtn.disabled = false;
        processBtn.innerHTML = '<i class="fas fa-play"></i> 开始处理PDF文件';
      };

      xhr.onerror = () => {
        progressText.textContent = "网络错误！";
        alert("网络错误，请检查连接后重试");
        processBtn.disabled = false;
        processBtn.innerHTML = '<i class="fas fa-play"></i> 开始处理PDF文件';
      };

      xhr.send(form);
    }
  </script>
```
前端
```
<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PDF/Word预处理工具</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" />
  <style>
    .row {
      display: flex;
      gap: 20px;
    }

    .left-panel {
      flex: 2;
    }

    .right-panel {
      flex: 1.5;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #preview-img {
      max-width: 100%;
      max-height: 500px;
      border-radius: var(--border-radius);
      box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2); /* 调整阴影 */
      border: 1px solid #eee;
      display: none;
    }

    :root {
      --primary-color: #4a6bff;
      --secondary-color: #6c757d;
      --success-color: #28a745;
      --danger-color: #dc3545;
      --light-color: #f8f9fa;
      --dark-color: #343a40;
      --border-radius: 8px;
      --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --transition: all 0.3s ease;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Roboto', sans-serif;
      line-height: 1.6;
      color: #333;
      background-color: #f5f7fa;
      padding: 20px;
      max-width: 1200px;
      margin: 0 auto;
    }
    
    .container {
      background-color: white;
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      padding: 30px;
      margin-top: 20px;
    }
    
    h1 {
      color: var(--primary-color);
      text-align: center;
      margin-bottom: 20px;
      font-weight: 500;
    }
    
    .section {
      margin-bottom: 15px;
      padding: 15px;
      border-radius: var(--border-radius);
      background-color: var(--light-color);
    }
    
    .section-title {
      font-size: 1.1rem;
      margin-bottom: 15px;
      color: var(--dark-color);
      display: flex;
      align-items: center;
    }
    
    .section-title i {
      margin-right: 10px;
      color: var(--primary-color);
    }
    
    .file-upload {
      border: 2px dashed #ccc;
      border-radius: var(--border-radius);
      padding: 30px;
      text-align: center;
      transition: var(--transition);
      margin-bottom: 15px;
      cursor: pointer;
    }
    
    .file-upload:hover {
      border-color: var(--primary-color);
      background-color: rgba(74, 107, 255, 0.05);
    }
    
    .file-upload.active {
      border-color: var(--success-color);
      background-color: rgba(40, 167, 69, 0.05);
    }
    
    #file-names {
      font-size: 0.9rem;
      color: var(--secondary-color);
      margin-top: 10px;
      word-break: break-all;
    }
    
    .form-group {
      margin-bottom: 20px;
    }
    
    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: var(--dark-color);
    }
    
    input[type="number"],
    input[type="file"] {
      width: 100%;
      padding: 10px 15px;
      border: 1px solid #ddd;
      border-radius: var(--border-radius);
      font-size: 1rem;
      transition: var(--transition);
    }
    
    input[type="number"]:focus,
    input[type="file"]:focus {
      outline: none;
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(74, 107, 255, 0.2);
    }
    
    .input-group {
      display: flex;
      gap: 15px;
    }
    
    .input-group .form-group {
      flex: 1;
    }
    
    .btn {
      display: inline-block;
      padding: 12px 24px;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      transition: var(--transition);
      text-align: center;
      margin-right: 10px;
      margin-bottom: 10px;
    }
    
    .btn:hover {
      background-color: #3a5bef;
      transform: translateY(-2px);
    }
    
    .btn-secondary {
      background-color: var(--secondary-color);
    }
    
    .btn-secondary:hover {
      background-color: #5a6268;
    }
    
    .btn-block {
      display: block;
      width: 100%;
    }
    
    #preview-container {
      width: 400px;
      height: 465px;
      margin: 10px 20px;
      text-align: center;
    }
    
    #preview-img {
      max-width: 100%;
      max-height: 450px;
      border-radius: var(--border-radius);      
      border: 1px solid #eee;
      display: none;
    }
    
    .progress-container {
      margin: 25px 0;
    }
    
    progress {
      width: 100%;
      height: 10px;
      border-radius: 5px;
      margin-bottom: 10px;
    }
    
    progress::-webkit-progress-bar {
      background-color: #eee;
      border-radius: 5px;
    }
    
    progress::-webkit-progress-value {
      background-color: var(--primary-color);
      border-radius: 5px;
      transition: var(--transition);
    }
    
    #download-links {
      margin-top: 25px;
      text-align: center;
    }
    
    .download-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 12px 24px;
      background-color: var(--success-color);
      color: white;
      text-decoration: none;
      border-radius: var(--border-radius);
      transition: var(--transition);
    }
    
    .download-btn:hover {
      background-color: #218838;
      transform: translateY(-2px);
    }
    
    .download-btn i {
      margin-right: 8px;
    }
    
    .hidden {
      display: none !important;
    }
    

    @media (max-width: 768px) {
      .row {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1><i class="fas fa-file-pdf"></i> PDF/Word预处理工具</h1>
    
    <div class="row">
      <!-- 左侧部分 -->
      <div class="left-panel">
        <div class="section">
          <h2 class="section-title"><i class="fas fa-cloud-upload-alt"></i> 上传PDF/Word文件</h2>
          <div class="file-upload" id="file-upload-area">
            <input type="file" id="pdf-input" multiple accept=".pdf,.doc,.docx" hidden>
            <p><i class="fas fa-upload"></i> 点击或拖放PDF/Word文件到此处</p>
            <p class="text-muted">支持一次性多文件上传</p>
          </div>
          <p id="file-names" class="text-muted"></p>
        </div>
        
        <div class="section">
          <h2 class="section-title"><i class="fas fa-cut"></i> 裁剪设置 <p class="text-muted">（请根据需要裁除页眉页尾）</p> </h2>
          
          <div class="input-group">
            <div class="form-group">
              <label for="top"><i class="fas fa-arrow-up"></i> 上（页眉）裁剪距离 (cm)</label>
              <input type="number" id="top" value="2.5" step="0.1" min="0">
            </div>
            <div class="form-group">
              <label for="bottom"><i class="fas fa-arrow-down"></i> 下（页尾）裁剪距离 (cm)</label>
              <input type="number" id="bottom" value="2.5" step="0.1" min="0">
            </div>
          </div>
        </div>
        
        <div class="section">
          <h2 class="section-title"><i class="fas fa-cog"></i> 处理</h2>
          <div class="progress-container" id="progress-container" style="display: none;">
            <progress id="progress-bar" value="0" max="100"></progress>
            <p class="text-muted" id="progress-text">处理中，请稍候...</p>
          </div>
          <div class="row" style="display: flex; gap: 10px;">
            <button class="btn btn-secondary" style="flex: 1;" onclick="previewPDF()">
              <i class="fas fa-image"></i> 预览剪裁效果
            </button>
            <button class="btn btn-secondary" style="flex: 1;" onclick="processPDFs()">
              <i class="fas fa-play"></i> 开始处理文件
            </button>
          </div>
        </div>
        
        
      </div>
      
      <!-- 右侧部分 -->
      <div class="right-panel">
        <div class="section">
          <h2 class="section-title"><i class="fas fa-eye"></i> 预览(多文件暂不支持)</h2>
          <div id="preview-container">

            <img id="preview-img" style="margin-top: 15px;" />
          </div>
        </div>
        <div id="download-links" class="hidden">          
          <a id="csv-link" href="#" class="download-btn">
            <i class="fas fa-file-csv"></i> <span id="download-text">下载CSV文件</span>
          </a>
        </div>
      </div>
    </div>
  </div>

  <script>
    // 文件上传区域交互
    const fileInput = document.getElementById("pdf-input");
    const fileUploadArea = document.getElementById("file-upload-area");
    
    fileUploadArea.addEventListener("click", () => {
      fileInput.click();
    });
    
    fileInput.addEventListener("change", () => {
      const names = Array.from(fileInput.files).map(f => f.name).join("；");
      document.getElementById("file-names").textContent = `已选择 ${fileInput.files.length} 个文件`;
      fileUploadArea.classList.add("active");
      
      // 显示前几个文件名
      if (fileInput.files.length > 0) {
        const sampleNames = Array.from(fileInput.files)
          .slice(0, 3)
          .map(f => f.name)
          .join(", ");
        document.getElementById("file-names").textContent = 
          `已选择 ${fileInput.files.length} 个文件 (示例: ${sampleNames}${fileInput.files.length > 3 ? "..." : ""})`;
      }
    });
    
    // 拖放功能
    fileUploadArea.addEventListener("dragover", (e) => {
      e.preventDefault();
      fileUploadArea.classList.add("active");
    });
    
    fileUploadArea.addEventListener("dragleave", () => {
      fileUploadArea.classList.remove("active");
    });
    
    fileUploadArea.addEventListener("drop", (e) => {
      e.preventDefault();
      fileUploadArea.classList.remove("active");
      
      if (e.dataTransfer.files.length) {
        fileInput.files = e.dataTransfer.files;
        const event = new Event("change");
        fileInput.dispatchEvent(event);
      }
    });
    
    // 预览功能
    function previewPDF() {
      const file = fileInput.files[0];
      if (!file) return alert("请选择一个文件进行预览");
      
      const form = new FormData();
      form.append("file", file);
      form.append("top_cm", document.getElementById("top").value);
      form.append("bottom_cm", document.getElementById("bottom").value);

      const previewBtn = document.querySelector('.btn-secondary[onclick="previewPDF()"]');
      previewBtn.disabled = true;
      previewBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 生成预览...';
      
      fetch("/preview/", { method: "POST", body: form })
        .then(res => res.json())
        .then(data => {
          const img = document.getElementById("preview-img");
          img.src = "/" + encodeURIComponent(data.preview_path);
          img.style.display = "block";
          previewBtn.disabled = false;
          previewBtn.innerHTML = '<i class="fas fa-image"></i> 预览剪裁效果';
        })
        .catch(() => {
          previewBtn.disabled = false;
          previewBtn.innerHTML = '<i class="fas fa-image"></i> 预览剪裁效果';
          alert("预览生成失败，请重试");
        });
    }
    
    // 处理功能
    function processPDFs() {
      const files = fileInput.files;
      if (files.length === 0) return alert("请上传PDF文件");
      
      const form = new FormData();
      for (let i = 0; i < files.length; i++) form.append("files", files[i]);
      form.append("top_cm", document.getElementById("top").value);
      form.append("bottom_cm", document.getElementById("bottom").value);

      const processBtn = document.querySelector('.btn-secondary[onclick="processPDFs()"]');
      processBtn.disabled = true;
      processBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 处理中...';
      
      document.getElementById("progress-container").style.display = "block";
      document.getElementById("download-links").classList.add("hidden");

      const xhr = new XMLHttpRequest();
      xhr.open("POST", "/process_batch/", true);

      const bar = document.getElementById("progress-bar");
      const progressText = document.getElementById("progress-text");
      
      bar.value = 0;
      progressText.textContent = "准备上传文件...";

      xhr.upload.onprogress = e => {
        if (e.lengthComputable) {
          const percent = Math.round((e.loaded / e.total) * 100);
          bar.value = percent;
          progressText.textContent = `上传中: ${percent}%`;
        }
      };

      xhr.onload = () => {
        try {
          const res = JSON.parse(xhr.responseText);
          document.getElementById("download-links").classList.remove("hidden");
          const csvLink = document.getElementById("csv-link");
          csvLink.href = `/download/?path=${encodeURIComponent(res.path)}`;
          
          if (res.is_zip) {
            document.getElementById("download-text").textContent = "下载CSV压缩包";
            csvLink.innerHTML = '<i class="fas fa-file-archive"></i> 下载CSV压缩包';
          } else {
            document.getElementById("download-text").textContent = "下载CSV文件";
            csvLink.innerHTML = '<i class="fas fa-file-csv"></i> 下载CSV文件';
          }
          
          progressText.textContent = "处理完成！";
          bar.value = 100;
        } catch (e) {
          progressText.textContent = "处理出错！";
          alert("处理过程中出错，请重试");
        }
        
        processBtn.disabled = false;
        processBtn.innerHTML = '<i class="fas fa-play"></i> 开始处理PDF文件';
      };

      xhr.onerror = () => {
        progressText.textContent = "网络错误！";
        alert("网络错误，请检查连接后重试");
        processBtn.disabled = false;
        processBtn.innerHTML = '<i class="fas fa-play"></i> 开始处理PDF文件';
      };

      xhr.send(form);
    }
  </script>
</body>
</html>
```
```
from fastapi.responses import FileResponse, JSONResponse

@app.post("/process_batch/")
async def process_batch(files: List[UploadFile] = File(...), top_cm: float = Form(...), bottom_cm: float = Form(...)):
    csv_paths = []
    errors = []

    for file in files:
        try:
            ext = file.filename.rsplit(".", 1)[-1].lower()

            if ext in ("doc", "docx"):
                pdf_path = convert_doc_to_pdf(file)
                with open(pdf_path, "rb") as f:
                    pdf_bytes = f.read()
                csv_path = process_pdf_and_extract(BytesIO(pdf_bytes), top_cm, bottom_cm, filename=file.filename)
            elif ext == "pdf":
                file_bytes = await file.read()
                csv_path = process_pdf_and_extract(BytesIO(file_bytes), top_cm, bottom_cm, filename=file.filename)
            else:
                raise ValueError(f"Unsupported file type: {file.filename}")

            csv_paths.append(csv_path)
        except Exception as e:
            print(f"❌ Error processing {file.filename}: {e}")
            errors.append(file.filename)

    if not csv_paths:
        return JSONResponse(status_code=500, content={"message": "All files failed", "errors": errors})

    if len(csv_paths) == 1:
        return FileResponse(csv_paths[0], filename=os.path.basename(csv_paths[0]))
    else:
        zip_path = zip_csvs(csv_paths)
        return FileResponse(zip_path, filename=os.path.basename(zip_path))


```
```
from fastapi.responses import JSONResponse

@app.post("/process_batch")
async def process_batch(
    files: List[UploadFile] = File(...),
    top_cm: float = Form(0),
    bottom_cm: float = Form(0)
):
    output_dir = "processed"
    os.makedirs(output_dir, exist_ok=True)

    results = []
    errors = []

    for file in files:
        filename = unquote(file.filename)
        ext = filename.split(".")[-1].lower()
        try:
            if ext in ("doc", "docx"):
                pdf_path = convert_doc_to_pdf(file)
                with open(pdf_path, "rb") as f:
                    pdf_bytes = f.read()
                csv_path = process_pdf_and_extract(BytesIO(pdf_bytes), top_cm, bottom_cm, filename=filename)
            elif ext == "pdf":
                pdf_bytes = await file.read()
                csv_path = process_pdf_and_extract(BytesIO(pdf_bytes), top_cm, bottom_cm, filename=filename)
            else:
                raise ValueError("Unsupported file type")
            results.append(csv_path)
        except Exception as e:
            print(f"❌ Error processing {filename}: {e}")
            errors.append(filename)
            continue

    if not results:
        return JSONResponse(status_code=500, content={"message": "All files failed to process", "errors": errors})

    # 生成结果 ZIP
    if len(results) == 1:
        return FileResponse(results[0], filename=os.path.basename(results[0]))
    else:
        zip_path = create_zip(results, output_dir)
        return FileResponse(zip_path, filename=os.path.basename(zip_path))


```
这个错误信息清晰地指出了你的问题出在这里：

```
TypeError: bad stream: type(stream)=<class 'str'>
```

### 错误根因：

你调用了 `fitz.open(stream=..., filetype="pdf")`，但传入的 `stream` 实际是一个字符串（str 类型），而不是期望的 `bytes`、`BytesIO` 或可读取流（比如文件对象）。

---

### 问题出现在你调用 `process_pdf_and_extract()` 的方式：

在 `app.py` 中第 63 行：

```python
csv_path = process_pdf_and_extract(pdf_path, top_cm, bottom_cm)
```

这里 `pdf_path` 是字符串路径，而你在 `process_pdf_and_extract()` 中调用的是：

```python
pdf = fitz.open(stream=file.read() if hasattr(file, "read") else file, filetype="pdf")
```

当传入的是字符串 `pdf_path`，就走到了 `else file`，即 `fitz.open(stream=pdf_path, filetype="pdf")`，而 `fitz.open()` 不支持字符串作为 `stream` 参数。

---

### ✅ 正确做法：

你应该改为：

```python
pdf = fitz.open(file)  # 如果是文件路径，直接传路径，fitz 会自动识别
```

或者更健壮：

```python
if hasattr(file, "read"):  # 是 BytesIO 或 UploadFile
    pdf = fitz.open(stream=file.read(), filetype="pdf")
else:  # 是路径字符串
    pdf = fitz.open(file)
```

---

### ✅ 推荐修复方案：

在 `process.py` 中 `process_pdf_and_extract()` 函数里，修改如下：

```python
import fitz  # PyMuPDF

def process_pdf_and_extract(file, top_cm, bottom_cm, filename=None):
    # 处理传入的 file 参数：可能是 BytesIO、UploadFile 或 str 路径
    if hasattr(file, "read"):
        pdf = fitz.open(stream=file.read(), filetype="pdf")
    elif isinstance(file, (bytes, bytearray)):
        pdf = fitz.open(stream=file, filetype="pdf")
    elif isinstance(file, str):
        pdf = fitz.open(file)  # 是一个 PDF 文件路径
    else:
        raise TypeError(f"Unsupported file input type: {type(file)}")

    # 后续你的逻辑保持不变...
```

---

### ✅ 补充建议：

你在上传 Word 文件时，用 `convert_doc_to_pdf(file)` 只返回了 PDF 路径（str），但 `process_pdf_and_extract()` 期望的是 BytesIO 或可读取对象。这两处的处理方式应该统一，比如将 Word 转 PDF 后读取内容为 BytesIO 传入，或者统一都让 `process_pdf_and_extract()` 支持文件路径。

---

### ✅ 统一处理建议（推荐）：

在 `app.py` 中修改：

```python
if ext in ("doc", "docx"):
    # Word 转 PDF 后读取 PDF 内容
    pdf_path = convert_doc_to_pdf(file)
    with open(pdf_path, "rb") as f:
        pdf_bytes = f.read()
    csv_path = process_pdf_and_extract(BytesIO(pdf_bytes), top_cm, bottom_cm, filename=file.filename)
```

这样你就不用修改 `process_pdf_and_extract()` 的实现方式了，保持所有传入都是 BytesIO，一致性更好。

---

如需我帮你重构完整代码或模块结构，也可以继续发我。

```
ERROR:    Exception in ASGI application
Traceback (most recent call last):
  File "/usr/local/lib/python3.9/site-packages/uvicorn/protocols/http/h11_impl.py", line 403, in run_asgi
    result = await app(  # type: ignore[func-returns-value]
  File "/usr/local/lib/python3.9/site-packages/uvicorn/middleware/proxy_headers.py", line 60, in __call__
    return await self.app(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/fastapi/applications.py", line 1054, in __call__
    await super().__call__(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/applications.py", line 112, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/middleware/errors.py", line 187, in __call__
    raise exc
  File "/usr/local/lib/python3.9/site-packages/starlette/middleware/errors.py", line 165, in __call__
    await self.app(scope, receive, _send)
  File "/usr/local/lib/python3.9/site-packages/starlette/middleware/cors.py", line 93, in __call__
    await self.simple_response(scope, receive, send, request_headers=headers)
  File "/usr/local/lib/python3.9/site-packages/starlette/middleware/cors.py", line 144, in simple_response
    await self.app(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/middleware/exceptions.py", line 62, in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/usr/local/lib/python3.9/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/usr/local/lib/python3.9/site-packages/starlette/routing.py", line 714, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/routing.py", line 734, in app
    await route.handle(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/routing.py", line 288, in handle
    await self.app(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/routing.py", line 76, in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
  File "/usr/local/lib/python3.9/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/usr/local/lib/python3.9/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/usr/local/lib/python3.9/site-packages/starlette/routing.py", line 73, in app
    response = await f(request)
  File "/usr/local/lib/python3.9/site-packages/fastapi/routing.py", line 301, in app
    raw_response = await run_endpoint_function(
  File "/usr/local/lib/python3.9/site-packages/fastapi/routing.py", line 212, in run_endpoint_function
    return await dependant.call(**values)
  File "/app/app.py", line 63, in process_batch
    csv_path = process_pdf_and_extract(pdf_path, top_cm, bottom_cm)
  File "/app/process.py", line 11, in process_pdf_and_extract
    pdf = fitz.open(stream=file.read() if hasattr(file, "read") else file, filetype="pdf")
  File "/usr/local/lib/python3.9/site-packages/pymupdf/__init__.py", line 2926, in __init__
    raise TypeError(f"bad stream: {type(stream)=}.")
TypeError: bad stream: type(stream)=<class 'str'>.
```
```
# process.py
import os
import fitz  # PyMuPDF
import csv
import re
from uuid import uuid4
from convert_doc import convert_doc_to_pdf
from io import BytesIO

os.makedirs("outputs", exist_ok=True)

def process_pdf_and_extract(file, top_cm, bottom_cm):
    filename = file.filename.rsplit(".", 1)[0]

    # 判断是否是 Word 文件
    ext = file.filename.rsplit(".", 1)[-1].lower()
    if ext in ("doc", "docx"):
        pdf_path = convert_doc_to_pdf(file)
        doc = fitz.open(pdf_path)
    else:
        # PDF 文件：使用 file.file.read()
        pdf_bytes = file.file.read()
        doc = fitz.open(stream=pdf_bytes, filetype="pdf")

    csv_path = f"outputs/{filename}.csv"
    heading_pattern = re.compile(r'^(\d+(\.\d+)*)(\s+)(.+)')  # 1、1.1、1.1.1 标题
    current_heading = None
    content_dict = {}

    for page in doc:
        rect = page.rect
        top = top_cm * 28.35
        bottom = bottom_cm * 28.35
        clip = fitz.Rect(rect.x0, rect.y0 + top, rect.x1, rect.y1 - bottom)
        blocks = page.get_text("blocks", clip=clip)
        sorted_blocks = sorted(blocks, key=lambda b: (b[1], b[0]))  # 从上到下排序

        for block in sorted_blocks:
            text = block[4].strip()
            if not text:
                continue
            match = heading_pattern.match(text)
            if match:
                current_heading = f"{match.group(1)} {match.group(4).strip()}"
                content_dict[current_heading] = ""
            elif current_heading:
                content_dict[current_heading] += text + " "

    with open(csv_path, "w", newline="", encoding="utf-8-sig") as f:
        writer = csv.writer(f)
        for heading, content in content_dict.items():
            writer.writerow([heading, content.strip()])

    return csv_path
```
