ä»¥ä¸‹æ˜¯å®Œæ•´çš„ PDF å‰ªè£ä¸ç»“æ„æå–å·¥å…·ï¼ˆæ”¯æŒé¢„è§ˆã€CSV æå–ã€è¿›åº¦æ¡ã€å¤šæ–‡æ¡£æ‰“åŒ…ä¸‹è½½ï¼‰å‰åç«¯ + Docker éƒ¨ç½²æ–¹æ¡ˆï¼š

---

## âœ… ä¸€ã€åŠŸèƒ½æ€»è§ˆ

æ”¯æŒåŠŸèƒ½ï¼š

* âœ… æ‹–æ‹½/å¤šé€‰ä¸Šä¼  PDFï¼›
* âœ… è®¾ç½®ä¸Šä¸‹è£å‰ªè·ç¦»ï¼›
* âœ… å‰ªè£æ•ˆæœé¢„è§ˆï¼›
* âœ… ç»“æ„åŒ–æ•°æ®æå–ä¸º CSVï¼›
* âœ… å¤šæ–‡æ¡£å‹ç¼©æ‰“åŒ…ï¼›
* âœ… ä¸‹è½½æŒ‰é’®åŠ¨æ€æ˜¾ç¤ºï¼›
* âœ… è¿›åº¦æ¡ï¼›
* âœ… Docker ä¸€é”®éƒ¨ç½²ã€‚

---

## ğŸ“ äºŒã€ç›®å½•ç»“æ„

```
pdf-tool/
â”œâ”€â”€ app.py
â”œâ”€â”€ process.py
â”œâ”€â”€ preview.py
â”œâ”€â”€ zip_util.py
â”œâ”€â”€ static/
â”‚   â”œâ”€â”€ index.html
â”‚   â””â”€â”€ style.css
â”œâ”€â”€ outputs/                  # è‡ªåŠ¨ç”Ÿæˆçš„é¢„è§ˆå›¾å’ŒCSV
â”œâ”€â”€ Dockerfile
â””â”€â”€ requirements.txt
```

---

## ğŸ ä¸‰ã€åç«¯æ ¸å¿ƒä»£ç ï¼ˆFastAPIï¼‰

### âœ… 1. `app.py`

```python
from fastapi import FastAPI, File, UploadFile, Form
from fastapi.responses import FileResponse, HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware
from typing import List
import os
from process import process_pdf_and_extract
from preview import generate_preview_image
from zip_util import zip_csvs

app = FastAPI()
app.mount("/static", StaticFiles(directory="static"), name="static")
app.mount("/outputs", StaticFiles(directory="outputs"), name="outputs")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_methods=["*"], allow_headers=["*"]
)

@app.get("/")
async def root():
    with open("static/index.html", "r", encoding="utf-8") as f:
        return HTMLResponse(content=f.read(), status_code=200)

@app.post("/preview/")
async def preview(file: UploadFile = File(...), top_cm: float = Form(...), bottom_cm: float = Form(...)):
    preview_path = generate_preview_image(file, top_cm, bottom_cm)
    return {"preview_path": preview_path}

@app.post("/process_batch/")
async def process_batch(files: List[UploadFile] = File(...), top_cm: float = Form(...), bottom_cm: float = Form(...)):
    csv_paths = []
    for file in files:
        csv_path = process_pdf_and_extract(file, top_cm, bottom_cm)
        csv_paths.append(csv_path)

    if len(csv_paths) == 1:
        return {"path": csv_paths[0], "is_zip": False}
    else:
        zip_path = zip_csvs(csv_paths)
        return {"path": zip_path, "is_zip": True}

@app.get("/download/")
async def download(path: str):
    return FileResponse(path, filename=os.path.basename(path))
```

---

### âœ… 2. `process.py`

```python
import os
import fitz  # PyMuPDF
import csv
from uuid import uuid4

os.makedirs("outputs", exist_ok=True)

def process_pdf_and_extract(file, top_cm, bottom_cm):
    pdf = fitz.open(stream=file.file.read(), filetype="pdf")
    filename = file.filename.rsplit('.', 1)[0]
    csv_path = f"outputs/{uuid4().hex}_{filename}.csv"

    with open(csv_path, "w", newline="", encoding="utf-8") as f:
        writer = csv.writer(f)
        for page in pdf:
            rect = page.rect
            top = top_cm * 28.35
            bottom = bottom_cm * 28.35
            clip = fitz.Rect(rect.x0, rect.y0 + top, rect.x1, rect.y1 - bottom)
            text = page.get_text("blocks", clip=clip)
            for block in text:
                writer.writerow([block[4].strip()])  # å†…å®¹

    return csv_path
```

---

### âœ… 3. `preview.py`

```python
import fitz
from uuid import uuid4
import os

def generate_preview_image(file, top_cm, bottom_cm):
    os.makedirs("outputs", exist_ok=True)
    pdf = fitz.open(stream=file.file.read(), filetype="pdf")
    page = pdf.load_page(0)
    rect = page.rect
    top = top_cm * 28.35
    bottom = bottom_cm * 28.35
    clip = fitz.Rect(rect.x0, rect.y0 + top, rect.x1, rect.y1 - bottom)

    pix = page.get_pixmap(dpi=150, clip=clip)
    path = f"outputs/{uuid4().hex}_preview.png"
    pix.save(path)
    return path
```

---

### âœ… 4. `zip_util.py`

```python
import zipfile
from uuid import uuid4
import os

def zip_csvs(paths):
    zip_name = f"outputs/{uuid4().hex}_csvs.zip"
    with zipfile.ZipFile(zip_name, 'w') as z:
        for path in paths:
            z.write(path, os.path.basename(path))
    return zip_name
```

---

## ğŸŒ å››ã€å‰ç«¯æ–‡ä»¶ï¼ˆé™æ€èµ„æºï¼‰

### âœ… `static/index.html`

```html
<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>PDFç»“æ„æå–å·¥å…·</title>
  <link rel="stylesheet" href="/static/style.css" />
</head>
<body>
  <h1>PDFç»“æ„æå–å·¥å…·</h1>

  <input type="file" id="pdf-input" multiple accept=".pdf">
  <p id="file-names" class="text-muted mt-2"></p>

  <label>ä¸Šè£å‰ªè·ç¦» (cm)ï¼š<input type="number" id="top" value="2" step="0.1"></label>
  <label>ä¸‹è£å‰ªè·ç¦» (cm)ï¼š<input type="number" id="bottom" value="2" step="0.1"></label>

  <button onclick="previewPDF()">é¢„è§ˆå‰ªè£æ•ˆæœ</button>
  <img id="preview-img" style="max-width: 100%; margin: 10px 0; display: none;" />

  <button onclick="processPDFs()">ç”Ÿæˆç»“æ„CSV</button>
  <progress id="progress-bar" value="0" max="100" style="width: 100%; display: none;"></progress>

  <div id="download-links" style="display: none;">
    <a id="csv-link" href="#" download>ä¸‹è½½</a>
  </div>

<script>
const input = document.getElementById("pdf-input");
input.addEventListener("change", () => {
  const names = Array.from(input.files).map(f => f.name).join("ï¼›");
  document.getElementById("file-names").textContent = "å·²é€‰æ–‡ä»¶ï¼š" + names;
});

function previewPDF() {
  const file = input.files[0];
  if (!file) return alert("è¯·é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶è¿›è¡Œé¢„è§ˆ");
  const form = new FormData();
  form.append("file", file);
  form.append("top_cm", document.getElementById("top").value);
  form.append("bottom_cm", document.getElementById("bottom").value);

  fetch("/preview/", { method: "POST", body: form })
    .then(res => res.json())
    .then(data => {
      const img = document.getElementById("preview-img");
      img.src = "/" + data.preview_path;
      img.style.display = "block";
    });
}

function processPDFs() {
  const files = input.files;
  if (files.length === 0) return alert("è¯·ä¸Šä¼ PDFæ–‡ä»¶");
  const form = new FormData();
  for (let i = 0; i < files.length; i++) form.append("files", files[i]);
  form.append("top_cm", document.getElementById("top").value);
  form.append("bottom_cm", document.getElementById("bottom").value);

  const xhr = new XMLHttpRequest();
  xhr.open("POST", "/process_batch/", true);

  const bar = document.getElementById("progress-bar");
  bar.style.display = "block";
  bar.value = 0;

  xhr.upload.onprogress = e => {
    if (e.lengthComputable) bar.value = (e.loaded / e.total) * 100;
  };

  xhr.onload = () => {
    const res = JSON.parse(xhr.responseText);
    document.getElementById("download-links").style.display = "block";
    const csvLink = document.getElementById("csv-link");
    csvLink.href = `/download/?path=${res.path}`;
    csvLink.textContent = res.is_zip ? "ä¸‹è½½CSVå‹ç¼©åŒ…" : "ä¸‹è½½CSVæ–‡ä»¶";
  };

  xhr.send(form);
}
</script>
</body>
</html>
```

---

### âœ… `static/style.css`ï¼ˆå¯é€‰ï¼‰

```css
body {
  max-width: 720px;
  margin: auto;
  font-family: sans-serif;
}
h1 {
  color: #007bff;
}
button {
  margin: 10px 0;
  padding: 8px 12px;
}
input[type="file"] {
  margin: 10px 0;
}
```

---

## ğŸ³ äº”ã€Dockeréƒ¨ç½²

### âœ… `requirements.txt`

```txt
fastapi
uvicorn
python-multipart
PyMuPDF
```

### âœ… `Dockerfile`

```Dockerfile
FROM python:3.10-slim

WORKDIR /app
COPY . /app

RUN pip install -r requirements.txt

EXPOSE 7860
CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "7860"]
```

---

## ğŸ§ª å…­ã€ä¸€é”®è¿è¡Œæµç¨‹

### âœ… æ„å»ºå¹¶è¿è¡Œå®¹å™¨ï¼š

```bash
docker build -t pdf-tool .
docker run -p 7860:7860 pdf-tool
```

è®¿é—®ï¼š[http://localhost:7860](http://localhost:7860)

---

## âœ… ä¸ƒã€æ€»ç»“

ä½ ç°åœ¨æ‹¥æœ‰ä¸€ä¸ªå®Œæ•´çš„å‰åç«¯ PDF å‰ªè£ä¸ç»“æ„æå–å·¥å…·ï¼Œæ”¯æŒï¼š

* å•/å¤šæ–‡æ¡£è£å‰ªï¼›
* è£å‰ªé¢„è§ˆï¼›
* CSVç»“æ„æå–ï¼›
* åŠ¨æ€ä¸‹è½½æŒ‰é’®ï¼›
* å¤šæ–‡æ¡£è‡ªåŠ¨å‹ç¼©ï¼›
* Docker ä¸€é”®éƒ¨ç½²ã€‚

éœ€è¦æˆ‘æ‰“åŒ…ä¸º `.zip` ä¾›ä½ ä¸‹è½½ï¼Œæˆ–è€…ç”Ÿæˆä¸€ä¸ª GitHub åˆå§‹åŒ–ä»“åº“ç»“æ„å—ï¼Ÿ
