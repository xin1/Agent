为了美化前端并增加预览功能，我们将对现有的 HTML 结构进行修改，提升用户体验。我们将基于 `FastAPI` 后端 + 静态 HTML 页面进行以下步骤。

---

### 📁 项目结构

```bash
pdf_tool/
├── app.py                  # FastAPI 应用主程序
├── pdf_processor.py        # PDF 剪裁+结构提取逻辑
├── templates/
│   └── index.html          # 静态网页（上传文件和下载结果）
├── static/                 # 静态资源（可留空）
├── requirements.txt        # Python 依赖
├── Dockerfile              # Docker 镜像构建配置
└── output/                 # 生成文件保存目录（Docker 会挂载）
```

---

### ✅ 1. `requirements.txt`

```txt
fastapi
uvicorn
python-multipart
jinja2
pdfplumber
PyMuPDF
```

---

### ✅ 2. `pdf_processor.py`

```python
import fitz  # PyMuPDF
import pdfplumber
import re
import csv
import os

def process_pdf(pdf_path: str, top_cm: float, bottom_cm: float):
    # 单位换算
    top_px = int(top_cm * 28.35)
    bottom_px = int(bottom_cm * 28.35)

    cropped_path = pdf_path.replace(".pdf", "_cropped.pdf")
    csv_path = pdf_path.replace(".pdf", ".csv")

    # 裁剪 PDF
    doc = fitz.open(pdf_path)
    for page in doc:
        rect = page.rect
        crop_rect = fitz.Rect(rect.x0, rect.y0 + top_px, rect.x1, rect.y1 - bottom_px)
        page.set_cropbox(crop_rect)
    doc.save(cropped_path)
    doc.close()

    # 提取结构化信息
    with open(csv_path, "w", newline='', encoding='utf-8-sig') as f:
        writer = csv.writer(f)
        writer.writerow(["标题", "内容"])

        current_title = None
        current_content = []

        with pdfplumber.open(cropped_path) as pdf:
            for page in pdf.pages:
                text = page.extract_text()
                if not text:
                    continue
                for line in text.split('\n'):
                    line = line.strip()
                    if not line:
                        continue
                    if is_heading(line):
                        if current_title:
                            writer.writerow([current_title, '\n'.join(current_content)])
                        current_title = line
                        current_content = []
                    elif current_title:
                        current_content.append(line)
        if current_title:
            writer.writerow([current_title, '\n'.join(current_content)])

    return cropped_path, csv_path

def is_heading(line):
    if len(line) > 50:
        return False
    return bool(re.match(r'^\d+(\.\d+){0,2}(\s+|$)', line.strip()))
```

---

### ✅ 3. `app.py`

```python
from fastapi import FastAPI, File, UploadFile, Form, Request
from fastapi.responses import HTMLResponse, FileResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from pathlib import Path
import shutil
import fitz  # PyMuPDF
import uuid
from pdf_utils import crop_pdf_and_extract_text  # 你已有的处理函数

app = FastAPI()
app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

UPLOAD_DIR = Path("uploads")
RESULT_DIR = Path("results")
PREVIEW_DIR = Path("previews")
UPLOAD_DIR.mkdir(exist_ok=True)
RESULT_DIR.mkdir(exist_ok=True)
PREVIEW_DIR.mkdir(exist_ok=True)

@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    return templates.TemplateResponse("index.html", {"request": request})

@app.post("/process/")
async def process_pdf(file: UploadFile = File(...), top_cm: float = Form(...), bottom_cm: float = Form(...)):
    # 保存上传文件
    uid = uuid.uuid4().hex
    input_pdf = UPLOAD_DIR / f"{uid}_{file.filename}"
    with input_pdf.open("wb") as f:
        shutil.copyfileobj(file.file, f)

    # 处理并生成输出
    cropped_pdf_path = RESULT_DIR / f"{uid}_cropped.pdf"
    csv_path = RESULT_DIR / f"{uid}_output.csv"
    crop_pdf_and_extract_text(input_pdf, cropped_pdf_path, csv_path, top_cm, bottom_cm)

    return JSONResponse({
        "pdf": f"/results/{cropped_pdf_path.name}",
        "csv": f"/results/{csv_path.name}"
    })

@app.get("/download/")
async def download_file(path: str):
    file_path = Path(path.strip("/"))
    if file_path.exists():
        return FileResponse(file_path, filename=file_path.name)
    return {"error": "文件不存在"}

@app.get("/preview/")
async def preview_image(pdf_path: str):
    pdf_file = Path(pdf_path.strip("/"))
    if not pdf_file.exists():
        return JSONResponse({"error": "PDF 文件未找到"}, status_code=404)

    # 生成预览图像
    doc = fitz.open(pdf_file)
    page = doc.load_page(0)
    pix = page.get_pixmap(dpi=150)
    img_path = PREVIEW_DIR / f"{pdf_file.stem}.jpg"
    pix.save(img_path)

    return FileResponse(img_path, media_type="image/jpeg")

```

---

### ✅ 4. `templates/index.html`（增加美化和预览功能）

```html
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>PDF裁剪与提取工具</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        #drop-area {
            border: 2px dashed #0d6efd;
            padding: 30px;
            text-align: center;
            color: #666;
            background-color: #f8f9fa;
            border-radius: 10px;
            transition: all 0.3s ease;
        }
        #drop-area.hover {
            border-color: #198754;
            background-color: #e9fbe5;
        }
        #file-name {
            margin-top: 10px;
            font-weight: bold;
            color: #0d6efd;
        }
    </style>
</head>
<body class="bg-light">
<div class="container py-5">
    <h2 class="mb-4 text-center text-primary">📄 PDF裁剪与结构提取工具</h2>
    <div class="row">
        <div class="col-md-6">
            <!-- 拖拽上传区 -->
            <div id="drop-area" class="mb-3">
                <p>将 PDF 文件拖拽到此处，或点击下方上传</p>
                <div id="file-name">未选择文件</div>
            </div>

            <form id="upload-form" enctype="multipart/form-data" class="bg-white p-4 shadow rounded">
                <div class="mb-3">
                    <input class="form-control" type="file" id="file" name="file" accept="application/pdf" required>
                </div>
                <div class="row mb-3">
                    <div class="col">
                        <label class="form-label">上边距裁剪 (cm)</label>
                        <input class="form-control" type="number" name="top_cm" id="top_cm" value="2.5" step="0.1">
                    </div>
                    <div class="col">
                        <label class="form-label">下边距裁剪 (cm)</label>
                        <input class="form-control" type="number" name="bottom_cm" id="bottom_cm" value="2.5" step="0.1">
                    </div>
                </div>
                <button class="btn btn-primary w-100" type="submit">📤 提交处理</button>
            </form>

            <div id="download-links" class="text-center mt-4" style="display:none;">
                <a id="pdf-link" class="btn btn-success me-2" download>📥 下载裁剪后 PDF</a>
                <a id="csv-link" class="btn btn-outline-primary" download>📊 下载结构化 CSV</a>
            </div>
        </div>

        <!-- 右侧预览 -->
        <div class="col-md-6 d-flex flex-column align-items-center justify-content-center">
            <h5 class="text-success mb-3">✅ 剪裁预览</h5>
            <div id="preview" style="display:none;">
                <img id="preview-image" class="img-fluid border rounded shadow" style="max-height: 600px;" alt="裁剪预览图">
            </div>
        </div>
    </div>
</div>

<script>
const dropArea = document.getElementById("drop-area");
const fileInput = document.getElementById("file");
const fileNameDisplay = document.getElementById("file-name");

// 拖拽处理
["dragenter", "dragover"].forEach(evt => {
    dropArea.addEventListener(evt, (e) => {
        e.preventDefault();
        dropArea.classList.add("hover");
    });
});
["dragleave", "drop"].forEach(evt => {
    dropArea.addEventListener(evt, (e) => {
        e.preventDefault();
        dropArea.classList.remove("hover");
    });
});
dropArea.addEventListener("drop", function (e) {
    const files = e.dataTransfer.files;
    if (files.length > 0) {
        fileInput.files = files;
        fileNameDisplay.textContent = files[0].name;
    }
});
fileInput.addEventListener("change", () => {
    if (fileInput.files.length > 0) {
        fileNameDisplay.textContent = fileInput.files[0].name;
    }
});

// 表单提交逻辑
document.getElementById("upload-form").addEventListener("submit", async function (e) {
    e.preventDefault();
    const file = fileInput.files[0];
    if (!file) return alert("请选择一个 PDF 文件");

    const top_cm = document.getElementById("top_cm").value;
    const bottom_cm = document.getElementById("bottom_cm").value;
    const formData = new FormData();
    formData.append("file", file);
    formData.append("top_cm", top_cm);
    formData.append("bottom_cm", bottom_cm);

    const response = await fetch("/process/", {
        method: "POST",
        body: formData
    });

    if (!response.ok) {
        alert("处理失败，请检查文件或参数");
        return;
    }

    const result = await response.json();
    // 更新预览图
    document.getElementById("preview").style.display = "block";
    document.getElementById("preview-image").src = `/preview/?pdf_path=${encodeURIComponent(result.pdf)}&t=${Date.now()}`;
    // 更新下载链接
    document.getElementById("download-links").style.display = "block";
    document.getElementById("pdf-link").href = `/download/?path=${encodeURIComponent(result.pdf)}`;
    document.getElementById("csv-link").href = `/download/?path=${encodeURIComponent(result.csv)}`;
});
</script>
</body>
</html>

```

---

### ✅ 5. `Dockerfile`

```Dockerfile
FROM python:3.10
WORKDIR /app

COPY . . 

RUN pip install --no-cache-dir -r requirements.txt

EXPOSE 8000

CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "8000"]
```

---

### ✅ 6. 构建并运行 Docker 容器

```bash
# 进入项目目录
cd pdf_tool

# 构建镜像
docker build -t pdf-tool-app .

# 启动容器（指定端口映射）
docker run -d -p 8090:8000 --name pdf_tool_app pdf-tool-app
```

然后访问：

```
http://<你的云服务器IP>:8090/
```

---

这样，您就可以通过 Docker 容器运行项目，并提供一个美观的前端页面，用户可以上传 PDF 文件，设置裁剪参数，预览结果，并下载裁剪后的 PDF 和结构化的 CSV 文件。

<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>PDF剪裁与提取工具</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="bg-light">
<div class="container py-5">
    <h2 class="mb-4 text-center text-primary">📄 PDF裁剪与结构提取工具</h2>
    <form id="upload-form" enctype="multipart/form-data" class="bg-white p-4 shadow rounded">
        <div class="mb-3">
            <label for="file" class="form-label">上传PDF文件</label>
            <input class="form-control" type="file" id="file" name="file" accept="application/pdf" required>
        </div>
        <div class="row mb-3">
            <div class="col">
                <label class="form-label">上边距裁剪 (cm)</label>
                <input class="form-control" type="number" name="top_cm" value="2.5" step="0.1">
            </div>
            <div class="col">
                <label class="form-label">下边距裁剪 (cm)</label>
                <input class="form-control" type="number" name="bottom_cm" value="2.5" step="0.1">
            </div>
        </div>
        <button class="btn btn-primary w-100" type="submit">提交处理</button>
    </form>

    <div id="preview" class="text-center my-4" style="display:none;">
        <h5 class="text-success">✅ 预览剪裁效果</h5>
        <img id="preview-image" class="img-fluid border rounded shadow" alt="裁剪预览图">
    </div>

    <div id="download-links" class="text-center mt-4" style="display:none;">
        <a id="pdf-link" class="btn btn-success me-2" download>下载裁剪后 PDF</a>
        <a id="csv-link" class="btn btn-outline-primary" download>下载结构化 CSV</a>
    </div>
</div>

<script>
document.getElementById("upload-form").addEventListener("submit", async function (e) {
    e.preventDefault();

    const form = e.target;
    const formData = new FormData(form);
    const file = form.file.files[0];

    if (!file) return alert("请选择一个 PDF 文件");

    const response = await fetch("/process/", {
        method: "POST",
        body: formData
    });

    if (!response.ok) {
        alert("处理失败，请检查文件格式或重试");
        return;
    }

    const result = await response.json();
    document.getElementById("preview").style.display = "block";
    document.getElementById("preview-image").src = `/preview/?pdf_path=${encodeURIComponent(result.pdf)}`;

    document.getElementById("download-links").style.display = "block";
    document.getElementById("pdf-link").href = `/download/?path=${encodeURIComponent(result.pdf)}`;
    document.getElementById("csv-link").href = `/download/?path=${encodeURIComponent(result.csv)}`;
});
</script>
</body>
</html>

from fastapi import FastAPI, UploadFile, File, Form
from fastapi.responses import FileResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
import os
from io import BytesIO
from PyPDF2 import PdfReader, PdfWriter
import pandas as pd

app = FastAPI()

# 静态文件目录，供前端预览和下载使用
app.mount("/static", StaticFiles(directory="static"), name="static")

# 临时目录
TEMP_DIR = "temp"

# 确保临时目录存在
os.makedirs(TEMP_DIR, exist_ok=True)

def crop_pdf(input_path: str, output_path: str, top_cm: float, bottom_cm: float):
    # 裁剪PDF函数
    reader = PdfReader(input_path)
    writer = PdfWriter()

    # 转换厘米为点（1 cm ≈ 28.35 points）
    top = top_cm * 28.35
    bottom = bottom_cm * 28.35

    # 对每一页进行裁剪
    for page_num in range(len(reader.pages)):
        page = reader.pages[page_num]
        page.cropbox.upper_left = (0, top)  # 左上
        page.cropbox.lower_right = (page.mediabox.width, page.mediabox.height - bottom)  # 右下
        writer.add_page(page)

    # 保存裁剪后的PDF
    with open(output_path, "wb") as out_file:
        writer.write(out_file)

def generate_csv_from_pdf(input_path: str) -> str:
    # 示例函数：从PDF提取一些结构化数据
    # 这里只是模拟，将PDF页面数作为结构化数据
    reader = PdfReader(input_path)
    data = {"page_number": list(range(1, len(reader.pages) + 1))}
    df = pd.DataFrame(data)
    
    # 保存为CSV
    csv_path = os.path.join(TEMP_DIR, "output.csv")
    df.to_csv(csv_path, index=False)
    return csv_path

@app.post("/process/")
async def process_pdf(file: UploadFile = File(...), top_cm: float = Form(2.5), bottom_cm: float = Form(2.5)):
    # 保存上传的PDF文件
    input_pdf_path = os.path.join(TEMP_DIR, file.filename)
    with open(input_pdf_path, "wb") as f:
        f.write(await file.read())

    # 输出裁剪后的PDF路径
    output_pdf_path = os.path.join(TEMP_DIR, f"cropped_{file.filename}")
    crop_pdf(input_pdf_path, output_pdf_path, top_cm, bottom_cm)

    # 生成结构化CSV
    csv_path = generate_csv_from_pdf(input_pdf_path)

    # 返回处理结果
    return JSONResponse(content={
        "pdf": output_pdf_path.replace(TEMP_DIR + "/", ""),
        "csv": csv_path.replace(TEMP_DIR + "/", "")
    })

@app.get("/preview/")
async def preview_pdf(pdf_path: str):
    # 返回裁剪后的PDF预览（这里假设前端传的是一个图片路径，实际可用PDF渲染器如PDF.js）
    return FileResponse(pdf_path)

@app.get("/download/")
async def download_file(path: str):
    file_path = os.path.join(TEMP_DIR, path)
    if os.path.exists(file_path):
        return FileResponse(file_path, media_type="application/octet-stream", filename=path)
    return JSONResponse(content={"message": "File not found"}, status_code=404)


project/
├── app/
│   ├── main.py              # FastAPI 后端服务入口
│   ├── pdf_processor.py     # 剪裁 PDF 和结构化提取逻辑
│   ├── utils.py             # 中间页生成预览图的工具函数
│   ├── static/
│   │   └── index.html       # 前端网页（上传、预览、下载）
│   └── outputs/             # 生成的 PDF/CSV/JPEG 临时文件目录
├── Dockerfile               # Docker 构建文件
├── requirements.txt         # 依赖清单
└── README.md                # 部署与使用说明

# --- app/pdf_processor.py ---
import fitz  # PyMuPDF
import re
import os

def crop_pdf(input_pdf, output_pdf, top_crop, bottom_crop):
    doc = fitz.open(input_pdf)
    for page in doc:
        rect = page.rect
        crop_rect = fitz.Rect(
            rect.x0, rect.y0 + top_crop, rect.x1, rect.y1 - bottom_crop
        )
        page.set_cropbox(crop_rect)
    doc.save(output_pdf)
    doc.close()

def extract_text_to_csv(input_pdf, output_csv, top_crop, bottom_crop):
    import csv
    doc = fitz.open(input_pdf)
    with open(output_csv, 'w', newline='', encoding='utf-8-sig') as f:
        writer = csv.writer(f)
        writer.writerow(['标题', '内容'])
        current_title = None
        current_content = []
        for page in doc:
            rect = page.rect
            crop_rect = fitz.Rect(rect.x0, rect.y0 + top_crop, rect.x1, rect.y1 - bottom_crop)
            text = page.get_text(clip=crop_rect)
            if not text:
                continue
            for line in text.split('\n'):
                line = line.strip()
                if not line:
                    continue
                if is_header(line):
                    if current_title:
                        writer.writerow([current_title, '\n'.join(current_content)])
                    current_title = line
                    current_content = []
                else:
                    current_content.append(line)
        if current_title:
            writer.writerow([current_title, '\n'.join(current_content)])
    doc.close()

def is_header(line):
    return bool(re.match(r'^\d+(\.\d+){0,2}\s+', line)) and len(line) <= 50

# --- app/utils.py ---
import fitz
from PIL import Image

def generate_middle_preview(input_pdf, output_image_path, top_crop, bottom_crop):
    doc = fitz.open(input_pdf)
    if len(doc) == 0:
        return False
    mid_index = len(doc) // 2
    page = doc[mid_index]
    rect = page.rect
    crop_rect = fitz.Rect(
        rect.x0, rect.y0 + top_crop, rect.x1, rect.y1 - bottom_crop
    )
    pix = page.get_pixmap(clip=crop_rect, dpi=150)
    img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
    img.save(output_image_path)
    doc.close()
    return True

# --- app/main.py ---
from fastapi import FastAPI, UploadFile, Form, File
from fastapi.responses import FileResponse, HTMLResponse
from fastapi.staticfiles import StaticFiles
import os
import shutil
from pdf_processor import crop_pdf, extract_text_to_csv
from utils import generate_middle_preview

app = FastAPI()
app.mount("/static", StaticFiles(directory="app/static"), name="static")

@app.get("/")
def index():
    with open("app/static/index.html", "r", encoding="utf-8") as f:
        return HTMLResponse(f.read())

@app.post("/process")
async def process(file: UploadFile = File(...), top_cm: float = Form(2.5), bottom_cm: float = Form(2.5)):
    filename = file.filename
    temp_path = f"app/outputs/{filename}"
    with open(temp_path, "wb") as f:
        shutil.copyfileobj(file.file, f)
    top_px = top_cm * 28.35
    bottom_px = bottom_cm * 28.35
    cropped_pdf = f"app/outputs/cropped_{filename}"
    csv_path = f"app/outputs/structured_{filename.replace('.pdf','.csv')}"
    jpg_path = f"app/outputs/preview_{filename.replace('.pdf','.jpg')}"

    crop_pdf(temp_path, cropped_pdf, top_px, bottom_px)
    extract_text_to_csv(temp_path, csv_path, top_px, bottom_px)
    generate_middle_preview(temp_path, jpg_path, top_px, bottom_px)
    os.remove(temp_path)
    return {
        "preview": f"/{jpg_path}",
        "pdf": f"/{cropped_pdf}",
        "csv": f"/{csv_path}"
    }

@app.get("/download")
def download(path: str):
    return FileResponse(path, filename=os.path.basename(path))

# --- app/static/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PDF 剪裁工具</title>
</head>
<body>
  <h2>上传 PDF 文件</h2>
  <form id="uploadForm">
    <input type="file" name="file" required><br>
    <label>页眉 (cm): <input type="number" name="top_cm" value="2.5"></label><br>
    <label>页脚 (cm): <input type="number" name="bottom_cm" value="2.5"></label><br>
    <button type="submit">提交处理</button>
  </form>
  <div id="result" style="display:none">
    <h3>预览中间页：</h3>
    <img id="preview" style="max-width:600px"><br>
    <a id="pdfLink" download>下载裁剪后 PDF</a> |
    <a id="csvLink" download>下载提取后的 CSV</a>
  </div>
  <script>
    const form = document.getElementById("uploadForm")
    form.onsubmit = async (e) => {
      e.preventDefault()
      const data = new FormData(form)
      const res = await fetch("/process", {method: "POST", body: data})
      const json = await res.json()
      document.getElementById("preview").src = json.preview
      document.getElementById("pdfLink").href = json.pdf
      document.getElementById("csvLink").href = json.csv
      document.getElementById("result").style.display = "block"
    }
  </script>
</body>
</html>

# --- requirements.txt ---
fastapi
uvicorn
python-multipart
PyMuPDF
pillow

# --- Dockerfile ---
FROM python:3.10-slim
WORKDIR /app
COPY . /app
RUN pip install --no-cache-dir -r requirements.txt
EXPOSE 8000
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
